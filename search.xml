<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>DNS部署与安全</title>
      <link href="/2020/06/12/dns-bu-shu-yu-an-quan/"/>
      <url>/2020/06/12/dns-bu-shu-yu-an-quan/</url>
      
        <content type="html"><![CDATA[<blockquote><p>网安个人学习</p></blockquote><h2 id="DNS部署与安全"><a href="#DNS部署与安全" class="headerlink" title="DNS部署与安全"></a>DNS部署与安全</h2><h3 id="1-DNS"><a href="#1-DNS" class="headerlink" title="1.DNS"></a>1.DNS</h3><p>Domain Name Services</p><p>域名服务</p><p>作用：为客户机提供域名解析服务器</p><h3 id="2-域名组成"><a href="#2-域名组成" class="headerlink" title="2.域名组成"></a>2.域名组成</h3><h4 id="2-1-域名组成概述"><a href="#2-1-域名组成概述" class="headerlink" title="2.1 域名组成概述"></a>2.1 域名组成概述</h4><p>如”<a href="www.baidu.com"></a>“为一个域名，严格来说：baidu.com”才是一个域名（唯一）,”www”为主机名。</p><p>“主机名.域名”为完全限定域名（FQDN–完全合格的域名）,一个域名可以有多个主机,但是<code>域名</code>则是唯一的,所以”主机名.域名”也是唯一的。</p><pre class=" language-域名"><code class="language-域名">nslookup 主机名.域名(查看IP地址)如： www.baidu.com..为根域.com为顶级域baidu为一级域www为主机名FQDN = 主机名.DNS后缀FQDN （完整合格的域名）</code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>DHCP部署与安全</title>
      <link href="/2020/06/10/dhcp-bu-shu-yu-an-quan/"/>
      <url>/2020/06/10/dhcp-bu-shu-yu-an-quan/</url>
      
        <content type="html"><![CDATA[<blockquote><p>网安个人学习</p></blockquote><h2 id="DHCP部署与安全"><a href="#DHCP部署与安全" class="headerlink" title="DHCP部署与安全"></a>DHCP部署与安全</h2><h3 id="1-DHCP作用"><a href="#1-DHCP作用" class="headerlink" title="1.DHCP作用"></a>1.DHCP作用</h3><p>（Dynamic Host Configure Protocol）自动分配ip</p><h3 id="2-概念"><a href="#2-概念" class="headerlink" title="2.概念"></a>2.概念</h3><p><code>地址池</code>/<code>作用域</code>：（<code>ip</code>，<code>子网掩码</code>，<code>网关</code>，<code>DNS</code>，<code>租期</code>）,<code>DHCP协议的端口</code>是<code>67/68</code></p><h3 id="3-优点"><a href="#3-优点" class="headerlink" title="3.优点"></a>3.优点</h3><p>减少工作量，避免ip冲突，提高地址利用率</p><h3 id="4-DHCP原理"><a href="#4-DHCP原理" class="headerlink" title="4.DHCP原理"></a>4.DHCP原理</h3><p>也叫做DHCP租约过程，（谁回应先到达，先用哪个），分为四步：</p><h4 id="1-发送DHCP-Discovery（发现）广播包。"><a href="#1-发送DHCP-Discovery（发现）广播包。" class="headerlink" title="1. 发送DHCP Discovery（发现）广播包。"></a>1. 发送<code>DHCP Discovery</code>（发现）广播包。</h4><p>（就像去租房，就需要去问哪有房租）</p><p> 客户机广播请求IP地址（包含客户机的MAC地址）</p><h4 id="2-响应DHCP-Offer广播包"><a href="#2-响应DHCP-Offer广播包" class="headerlink" title="2. 响应DHCP Offer广播包"></a>2. 响应<code>DHCP Offer</code>广播包</h4><p>（收到房东提供的房源信息）（即没有水卡，电卡等，只是告诉地址，去看房）</p><p> 服务器响应提供的IP地址（但无子网掩码，网关等参数）</p><h4 id="3-客户机发送DHCP-Request广播包"><a href="#3-客户机发送DHCP-Request广播包" class="headerlink" title="3. 客户机发送DHCP Request广播包"></a>3. 客户机发送<code>DHCP Request</code>广播包</h4><p>  （对于多个房源进行选择，看需要哪个房）</p><p>  客户机选择IP（也可以认为确定使用哪个IP）</p><h4 id="4-服务器发送DHCP-ACK（确认）广播包"><a href="#4-服务器发送DHCP-ACK（确认）广播包" class="headerlink" title="4. 服务器发送DHCP ACK（确认）广播包"></a>4. 服务器发送<code>DHCP ACK</code>（确认）广播包</h4><p>（房主确定租约，确定住房信息）</p><p>服务器<code>确认租约</code>，并提供网卡详细参数IP，掩码，网关，DNS，租约（提供的从地址池中去除）</p><p>（获取完地址时不再与服务器交流，直到续约到达一半时才会进行交流-续约-Request包）</p><h3 id="5-DHCP续约"><a href="#5-DHCP续约" class="headerlink" title="5.DHCP续约"></a>5.DHCP续约</h3><ul><li>当期约过<code>50%</code>后，客户机发送<code>DHCP Request包</code>，进行续约,根据实际情况来选择租约。（如：在肯德基里，使用的为短租约）</li></ul><ul><li>如果服务器无响应，则继续使用，并在85%发送DHCP Request包，进行续约，如果任然无响应，则需要释放IP地址，并重新发送DHCP </li></ul><p>Discovery广播包来获取IP地址</p><ul><li>当无服务器响应时，自动给自分配一个169.254.x.x/16 (255.255.0.0) （内网可以进行通信）</li></ul><h3 id="6-部署DHCP服务器"><a href="#6-部署DHCP服务器" class="headerlink" title="6.部署DHCP服务器"></a>6.部署DHCP服务器</h3><ol><li><p>IP地址固定（服务器必须固定IP地址）</p></li><li><p>IP地址保留</p><ol><li>去XP复制Mac地址</li><li>Win2003新建保留</li><li>输入信息</li></ol></li></ol><p><img src="https://res.cloudinary.com/valent/image/upload/v1591785070/Blog/%E7%BD%91%E7%BB%9C%E5%B7%A5%E7%A8%8B/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/DHCP/26_btjlgc.png" alt="保留"></p><ol start="4"><li><p>XP释放并获取： ipconfig /release   ipconfig /renew</p></li><li><p>获取的IP与我们设置的一样<br><img src="https://res.cloudinary.com/valent/image/upload/v1591785070/Blog/%E7%BD%91%E7%BB%9C%E5%B7%A5%E7%A8%8B/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/DHCP/27_wwx6vl.png" alt="IP"></p></li></ol><HR><h4 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h4><p>（使用xp–充当员工  与win2003–充当服务器 ）</p><ol><li>首先桥接网络 设置-网络适配器-特定虚拟网络  （必须配置相同）</li></ol><p><img src="https://res.cloudinary.com/valent/image/upload/v1591785071/Blog/%E7%BD%91%E7%BB%9C%E5%B7%A5%E7%A8%8B/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/DHCP/1_hgmlje.png" alt="桥接网络"></p><ol start="2"><li><p>xp自动获取ip即可</p></li><li><p>登录win2003,进行部署，部署为DHCP服务器</p></li><li><p>Win2003 开始-管理工具(查找DHCP，如果没有，则需要进行安装)</p></li><li><p>没有则导入Win2003 iso镜像，然后打开文件</p></li></ol><p><img src="https://res.cloudinary.com/valent/image/upload/v1591785071/Blog/%E7%BD%91%E7%BB%9C%E5%B7%A5%E7%A8%8B/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/DHCP/3_xvkyjm.png" alt="组件安装"></p><ol start="6"><li><p>双击<code>网络服务</code>-勾选<code>DHCP</code>-点击确定-下一步</p></li><li><p>服务器IP需要固定，则配置Win2003IP 为10.1.1.1 255.255.255.0</p></li></ol><p><img src="https://res.cloudinary.com/valent/image/upload/v1591785071/Blog/%E7%BD%91%E7%BB%9C%E5%B7%A5%E7%A8%8B/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/DHCP/4_by6kvb.png" alt="配置服务器"></p><ol start="8"><li>查看网络状态： netstat -an</li></ol><p><img src="https://res.cloudinary.com/valent/image/upload/v1591785071/Blog/%E7%BD%91%E7%BB%9C%E5%B7%A5%E7%A8%8B/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/DHCP/5_uvmve9.png" alt="netstat"></p><p><img src="https://res.cloudinary.com/valent/image/upload/v1591785071/Blog/%E7%BD%91%E7%BB%9C%E5%B7%A5%E7%A8%8B/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/DHCP/6_uenzws.png" alt="安装完成后出现端口67/68"></p><ol start="9"><li>接着使用DHCP 开始-管理工具-DHCP,右键关闭服务</li></ol><p><img src="https://res.cloudinary.com/valent/image/upload/v1591785071/Blog/%E7%BD%91%E7%BB%9C%E5%B7%A5%E7%A8%8B/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/DHCP/7_agjkxa.png" alt="停止"></p><ol start="10"><li>停止后发现67/68端口号没了，证明DHCP协议的端口号为 67/68</li></ol><p><img src="https://res.cloudinary.com/valent/image/upload/v1591785072/Blog/%E7%BD%91%E7%BB%9C%E5%B7%A5%E7%A8%8B/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/DHCP/8_ivxpn0.png" alt="协议端口"></p><ol start="11"><li>之后启动服务器，新建作用域，下一步-&gt;输入名称，描述-&gt;配置ip地址池-    &gt;添加排除-&gt;租约期限-&gt;设置网关-&gt;dns服务器-&gt;WIN服务器（不再使用，直接下一步）-&gt;激活（做实验可以激活，现实中先检查，ok再激活）-&gt;下一步 完成</li></ol><p><img src="https://res.cloudinary.com/valent/image/upload/v1591785072/Blog/%E7%BD%91%E7%BB%9C%E5%B7%A5%E7%A8%8B/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/DHCP/9_q45ot8.png" alt="创建作用域"></p><p><img src="https://res.cloudinary.com/valent/image/upload/v1591785072/Blog/%E7%BD%91%E7%BB%9C%E5%B7%A5%E7%A8%8B/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/DHCP/10_lq2d5u.png" alt="作用域名"></p><p>前后空出一些IP地址，排除开头结尾</p><p><img src="https://res.cloudinary.com/valent/image/upload/v1591785072/Blog/%E7%BD%91%E7%BB%9C%E5%B7%A5%E7%A8%8B/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/DHCP/11_s7y1ci.png" alt="IP地址池"></p><p>排除不分配IP</p><p><img src="https://res.cloudinary.com/valent/image/upload/v1591785072/Blog/%E7%BD%91%E7%BB%9C%E5%B7%A5%E7%A8%8B/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/DHCP/12_uk1sum.png" alt="排除IP"></p><p><img src="https://res.cloudinary.com/valent/image/upload/v1591785072/Blog/%E7%BD%91%E7%BB%9C%E5%B7%A5%E7%A8%8B/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/DHCP/13_ll707m.png" alt="设置期限"></p><p><img src="https://res.cloudinary.com/valent/image/upload/v1591785072/Blog/%E7%BD%91%E7%BB%9C%E5%B7%A5%E7%A8%8B/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/DHCP/14_ktw7jt.png" alt="设置网关"></p><p><img src="https://res.cloudinary.com/valent/image/upload/v1591785072/Blog/%E7%BD%91%E7%BB%9C%E5%B7%A5%E7%A8%8B/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/DHCP/15_pwfgwb.png" alt="给定IP"></p><ol start="12"><li>配置完成</li></ol><p><img src="https://res.cloudinary.com/valent/image/upload/v1591785072/Blog/%E7%BD%91%E7%BB%9C%E5%B7%A5%E7%A8%8B/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/DHCP/16_phgybu.png" alt="配置完成"></p><ol start="13"><li>进行验证，进入XP 网上邻居右键-》本地连接双击-》点击支持</li></ol><ol start="14"><li>如果文法正常显示，就拔掉网线（右键本地连接，点击停用，再开启，即可）</li></ol><p><img src="https://res.cloudinary.com/valent/image/upload/v1591785073/Blog/%E7%BD%91%E7%BB%9C%E5%B7%A5%E7%A8%8B/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/DHCP/17_goqybh.png" alt="配置成功"></p><ol start="15"><li>可能也会成功但是不是我们自己配置IP地址，这时先点击VM的编辑-&gt;虚拟网路编辑器 取消DHCP分配</li></ol><p><img src="https://res.cloudinary.com/valent/image/upload/v1591785070/Blog/%E7%BD%91%E7%BB%9C%E5%B7%A5%E7%A8%8B/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/DHCP/18_pyi4za.png" alt="DHCP分配"></p><ol start="16"><li>查看服务器WIN2003</li></ol><p><img src="https://res.cloudinary.com/valent/image/upload/v1591785070/Blog/%E7%BD%91%E7%BB%9C%E5%B7%A5%E7%A8%8B/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/DHCP/19_kwtzst.png" alt="服务器"></p><p><img src="https://res.cloudinary.com/valent/image/upload/v1591785069/Blog/%E7%BD%91%E7%BB%9C%E5%B7%A5%E7%A8%8B/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/DHCP/20_esywcn.png" alt="MAC地址"></p><p><img src="https://res.cloudinary.com/valent/image/upload/v1591785070/Blog/%E7%BD%91%E7%BB%9C%E5%B7%A5%E7%A8%8B/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/DHCP/21_jraipx.png" alt="XP ip详细信息"></p><ol start="17"><li>XP释放IP ： ipconfig /release   (即解除续约) </li></ol><p><img src="https://res.cloudinary.com/valent/image/upload/v1591785070/Blog/%E7%BD%91%E7%BB%9C%E5%B7%A5%E7%A8%8B/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/DHCP/22_ew5tpm.png" alt="解除续约"></p><p><img src="https://res.cloudinary.com/valent/image/upload/v1591785070/Blog/%E7%BD%91%E7%BB%9C%E5%B7%A5%E7%A8%8B/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/DHCP/23_q14krr.png" alt="地址租约解除"></p><ol start="18"><li>XP无ip发送<code>Discovery</code>包 获取IP    : ipconfig /renew</li></ol><p><img src="https://res.cloudinary.com/valent/image/upload/v1591785070/Blog/%E7%BD%91%E7%BB%9C%E5%B7%A5%E7%A8%8B/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/DHCP/24_hj1hsk.png" alt="获取IP"></p><ol start="19"><li>当又ip时再次发送： ipconfig /renew  相当于发送<code>request</code>包，获取续约</li></ol><p><img src="https://res.cloudinary.com/valent/image/upload/v1591785070/Blog/%E7%BD%91%E7%BB%9C%E5%B7%A5%E7%A8%8B/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/DHCP/25_xwvcat.png" alt="续约"></p><pre class=" language-客户机验证"><code class="language-客户机验证">ipconfig /release  当有IP时，释放IPipconfig /renew    当无ip时时自动获取IP；当有ip时再次执行相当于续约</code></pre><hr><h3 id="7-DHCP选项优先级"><a href="#7-DHCP选项优先级" class="headerlink" title="7.DHCP选项优先级"></a>7.DHCP选项优先级</h3><p><code>作用域选项</code>&gt;<code>服务器选项</code></p><p>当服务器上有多个的作用域时，可以在<code>服务器选项</code>设置<code>DNS服务器</code></p><h3 id="8-DHCP攻击与防御"><a href="#8-DHCP攻击与防御" class="headerlink" title="8.DHCP攻击与防御"></a>8.DHCP攻击与防御</h3><ol><li><p>攻击DHCP服务器： 频繁的发送伪装的<code>DHCP请求</code>,直到<code>DHCP地址池</code>完全耗尽（则无法访问服务器）</p></li><li><p>防御： 在交换机（管理型）的端口上做<code>动态MAC地址绑定</code>（动态绑定：来一个人访问即学，在拔网线之前无法更改，直至拔掉网线-消除缓存）（静态绑定：手工绑定端口，只允许一个访问，如果需要更改则需要向上申请）</p></li><li><p>伪装DHCP服务器攻击： hacker将自己伪装成<code>DHCP服务器</code>,为客户提供非法的ip地址（即hacker自己设定的ip）</p></li><li><p>防御： 在交换机（管理型）（只有管理型才可以进行配置）上，除合法的DHCP服务器所在的接口外，全部设置为<code>禁止发送DHCP Offer包</code></p></li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>编译原理</title>
      <link href="/2020/06/06/bian-yi-yuan-li/"/>
      <url>/2020/06/06/bian-yi-yuan-li/</url>
      
        <content type="html"><![CDATA[<blockquote><p>个人学习笔记</p></blockquote><h2 id="1-文法的定义"><a href="#1-文法的定义" class="headerlink" title="1.文法的定义"></a>1.文法的定义</h2><ul><li>文 法 G：定义为四元组（VN，VT，P，S），其中<br>  VN  ： 非终结符集<br>  VT  ： 终结符集<br>  P   ： 产生式（规则）集合<br>  S   ： 开始符号（起始符、识别符号）</li></ul><p>VN、VT 和 P 是非空有穷集。S 至少在一条规则中作为左部出现。VN∩VT= φ， S∈VN ，V=VN∪VT，称为文法G的字母表（字汇表）</p><p>如：</p><pre class=" language-文法"><code class="language-文法">文法G=（VN，VT，P，S）    VN = { S },             VT = { 0, 1 }    P  = { S→0S1,  S→01 }    S为开始符号或写成：    G[S]： S→0S1,  S→01 </code></pre><h3 id="1-文法约定"><a href="#1-文法约定" class="headerlink" title="1.文法约定"></a>1.文法约定</h3><ul><li><p>第一条产生式的左部是开始符号</p></li><li><p>用尖括号括起的是非终结符，否则为终结符。或者大写字母表示非终结符，小写字母表示终结符</p></li><li><p>G可写成G[S]，其中S是开始符号</p></li></ul><h3 id="2-文法的句型、句子的定义"><a href="#2-文法的句型、句子的定义" class="headerlink" title="2.文法的句型、句子的定义"></a>2.文法的句型、句子的定义</h3><ul><li>句型<ul><li>设G[S]是一文法，如果符号串x是从开始符号推导出来的，即S=&gt;x，则称x是文法G[S]的句型。</li><li>句型是推导过程中生成的产生式。<br>例如：<pre class=" language-例子"><code class="language-例子">有下列文法：　　S→AB　　A→aA|a　　B→bB|b用上述文法推导字符串aaabbb过程如下：S→AB→aAB→aaAB→aaaB→aaabB→aaabbB→aaabbbAB、aAB、aaAB、aaaB、aaabB、aaabbB和aaabbb都是上述文法的一个句型</code></pre></li></ul></li><li>句子<ul><li>X为只有终结符的句型为句子，则称x是G[S]的句子。<pre class=" language-例子"><code class="language-例子">此时句子为上述的： aaabbb</code></pre></li></ul></li></ul><h3 id="3-语言定义"><a href="#3-语言定义" class="headerlink" title="3.语言定义"></a>3.语言定义</h3><ul><li>由文法G生成的语言记为L(G)，它是文法G的全部句子（只有终结符）的集合:                                       L(G) = { x | S     <pre class=" language-例子"><code class="language-例子">例：G： S→0S1， S→01      L(G) = { 0n1n | n≥1 }</code></pre></li></ul><h3 id="4-文法等价"><a href="#4-文法等价" class="headerlink" title="4.文法等价"></a>4.文法等价</h3><ul><li>若L(G1) = L(G2)，则称文法G1和G2是等价的。<br>如<pre class=" language-文法"><code class="language-文法">G1[A]：A→0R  与G2[S]：S→0S1 等价           A→01           S→01           R→A1</code></pre>注：语言和文法的对应关系是一对多（1：n）的关系。</li></ul><h3 id="5-文法类型"><a href="#5-文法类型" class="headerlink" title="5.文法类型"></a>5.文法类型</h3><ul><li><p>0型文法：对任一产生式α→β，都有α∈(VN∪VT)+， β∈(VN∪VT)*</p></li><li><p>1型文法：对任一产生式α→β，都有|β|≥|α|， 仅仅 S→ε除外</p></li><li><p>2型文法：对任一产生式α→β，都有α∈VN ，β∈(VN∪VT)*</p></li><li><p>3型文法：任一产生式α→β的形式都为<br>(1) A→aB 或 A→a，其中A∈VN ，B∈VN ，a∈VT    (右线性文法)<br>(2) A→Ba 或 A→a，其中A∈VN ，B∈VN ，a∈VT    (左线性文法)</p><hr></li><li><p>1型文法：对任一产生式α→β，都有|β|≥|α|， 仅仅 S→ε除外</p></li><li><p>上下文有关文法： α1Aα2→α1βα2(A在VN中，其他在V*中，β≠ε)</p></li><li><p>2型文法：对任一产生式α→β，都有α∈VN ， β∈(VN∪VT)*</p></li><li><p>上下文无关文法：A→β(A在VN中，β在V*中，)</p></li><li><p>3型文法也叫正规文法</p></li></ul><pre class=" language-1型（上下文有关）文法"><code class="language-1型（上下文有关）文法">1型（上下文有关）文法   文法G[S]：    S→aSBE                S→aBE                EB→BE                aB→ab                bB→bb                bE→be                eE→ee</code></pre><pre class=" language-2型（上下文无关）文法"><code class="language-2型（上下文无关）文法">   文法G[S]：    S→aB|bA                A→a|aS|bAA                B→b|bS|aBB</code></pre><pre class=" language-3型文法"><code class="language-3型文法">    G[S]：  S→0A|1B|0            A→0A|1B|0S            B→1B|1|0</code></pre><h3 id="6-文法与语言"><a href="#6-文法与语言" class="headerlink" title="6.文法与语言"></a>6.文法与语言</h3><ul><li>0型文法( PSG )产生的语言称为0型语言</li><li>1型文法或上下文有关文法（ CSG ）产生的语言称为<code>1型语言</code>或<code>上下文有关语言</code>（CSL）</li><li>2型文法或上下文无关文法（ CFG ）产生的语言称为<code>2型语言</code>或<code>上下文无关语言</code>（ CF L ） </li><li>3型文法或正则（正规）文法（ RG ）产生的语言称为<code>3型语言</code>或<code>正则（正规）语言</code>（ RL ）</li></ul><h3 id="7-二义性"><a href="#7-二义性" class="headerlink" title="7.二义性"></a>7.二义性</h3><ul><li><p>给定一个文法G,存在一个句子S，S具有两颗不同的分析树，则该文法为<code>二义性文法</code></p></li><li><p>文法的某一个句子，它有两个（包括两个）以上的最右（最左）推导。则该文法为<code>二义性文法</code></p></li><li><p>文法的二义性和句子的二义性： 一个包含二义性文法的句子，称这个文法是二义性的。</p></li><li><p>文法的二义性和语言的二义性是不同的概念</p></li></ul><h3 id="8-自顶向下分析法"><a href="#8-自顶向下分析法" class="headerlink" title="8.自顶向下分析法"></a>8.自顶向下分析法</h3><ul><li>自上而下分析法（推导）：<br>  从文法的开始符号出发，反复使用各种产生式，寻找与输入符号匹配的推导。</li></ul><ol><li>LL(1)</li></ol><p>LL(1)分析法对于文法的要求：<br>对于 G 中的每个产生式 A →γ 1 | γ 2 | … | γ m ，其各候选式均应满足：<br>（1）不同的候选式不能推出以同一终结符号打头的符号串，即<br>FIRST( γ i ) ∩ FIRST( γ j )= φ（ 1 ≤ i ， j ≤ m ； i ≠ j ）<br>（2）若有γ j  ε，则其余候选式γ i 所能推出的符号串不能以 FOLLOW(A) 中的终结符号开始，即有<br>FIRST( γ i ) ∩ FOLLOW(A)= φ（ i ≤ 1,2, … ,m ； i ≠ j ）</p><h4 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h4><ol><li><code>LL(k)</code>文法(都不是)二义性的。</li></ol><h3 id="10-自下而上分析法"><a href="#10-自下而上分析法" class="headerlink" title="10.自下而上分析法"></a>10.自下而上分析法</h3><ul><li>自下而上分析法（归约）：<br>  从输入符号串开始，逐步进行归约，直至归约到文法的开始符号。</li></ul><ol><li><p>LR(0)</p></li><li><p>SLR(1)</p></li><li><p>LR(1)</p></li><li><p>LALR(1)</p></li></ol><h3 id="11-LL-1-、LR-0-、SLR-1-、LR-1-、LALR-1-文法的对比"><a href="#11-LL-1-、LR-0-、SLR-1-、LR-1-、LALR-1-文法的对比" class="headerlink" title="11.LL(1) 、LR(0)、SLR(1)、LR(1)、LALR(1)文法的对比"></a>11.LL(1) 、LR(0)、SLR(1)、LR(1)、LALR(1)文法的对比</h3><p><img src="https://res.cloudinary.com/valent/image/upload/v1591447825/Blog/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/1_bqhd1j.png" alt="对比图"></p><p>上图是四种文法的包含关系，即 LR(1)文法范围最大，而 LR(0)文法范围最小。同时也说明了四种文法分析过程的强弱，即 LR(1)文法分析最强，而 LR(0)文法分析最弱。</p><h3 id="12-短语、直接短语、句柄的定义"><a href="#12-短语、直接短语、句柄的定义" class="headerlink" title="12.短语、直接短语、句柄的定义"></a>12.短语、直接短语、句柄的定义</h3><ol><li><p>短语</p></li><li><p>素短语: 是一个短语，它至少包含一个终结符，且除自身外不再包含其他素短语。</p></li><li><p>直接短语: 若有 A =&gt;β则称β是句型αβδ相对于规则A→β的直接短语（或简单短语）</p></li><li><p>句柄: 一个句型的最左直接短语称为该句型的句柄。</p></li><li><p>一棵语法树表示了一个句型所有的不同推导过程，包括<code>最右推导</code>和<code>最左推导</code></p></li></ol><h3 id="13-文法化简"><a href="#13-文法化简" class="headerlink" title="13.文法化简"></a>13.文法化简</h3><ul><li><p>文法中不得含有有害规则和多余规则</p><ul><li>有害规则：形如U→U的产生式。会引起文法的二义性。</li><li>多余规则：指文法中任何句子的推导都不会用到的规则。<ol><li>文法中某些非终结符不在任何规则的右部出现，该非终结符称为不可到达的。</li><li>文法中某些非终结符，由它不能推出终结符号串来，称为不可终止的。</li></ol></li></ul></li><li><p>对于文法G[S]，为了保证任一非终结符A在句子推导中出现，必须满足如下两个条件：</p><ol><li><p>A必须在某句型中出现。</p></li><li><p>必须能从A推出终结符号串t来。</p><p>即： </p></li><li><p>文法G[S]，对某两个符号串α和β：S(<code>*</code>)=&gt;αAβ<br>2。 A (+)=&gt;  t ,t∈VT*    (一步推导到终结符)</p></li></ol></li></ul><p>注： (<code>*</code>)=&gt;包含0步推导(多步推导)；而 (+)=&gt;不包含0步推导（一步推导）。</p><p>如：</p><pre class=" language-化简文法"><code class="language-化简文法">G[S] ： S → ASe | BCaD | aD | AC A → Cb | DBS C → bC | d B → Ac D → aD </code></pre><ol><li><p>首先先写出所有的非终态，即：S A B C D</p></li><li><p>去除无法推出终结符的 D</p></li><li><p>去除无法推到的产生式子 B-&gt;Ac</p></li></ol><p>得出</p><pre class=" language-化简"><code class="language-化简">G[S] ： S → ASe | AC A → CbC → bC | d  </code></pre><h2 id="2-词法分析"><a href="#2-词法分析" class="headerlink" title="2.词法分析"></a>2.词法分析</h2><ul><li>词法分析程序的设计</li><li>单词的描述工具</li><li>有限自动机</li><li>正规式和有穷自动机的等价性</li><li>正规文法和有穷自动机间的转换</li><li>词法分析程序的自动构造工具</li></ul><h3 id="1-单词的描述工具"><a href="#1-单词的描述工具" class="headerlink" title="1.单词的描述工具"></a>1.单词的描述工具</h3><ul><li>正规文法：<br>文法G=（VN，VT，P，S），P中每一产生式的形式都为：<br>① A→aB 或 A→a，（右线型文法）<br>② A→Ba 或 A→a，（左线型文法）<br>其中：A∈VN ，B∈VN ， a∈VT</li></ul><h3 id="2-正规式的运算律"><a href="#2-正规式的运算律" class="headerlink" title="2.正规式的运算律"></a>2.正规式的运算律</h3><ul><li>设 r, s, t 为正规式，正规式服从的代数规律有：<br>1、 r|s = s|r        “或”服从交换律<br>2、 r|(s|t) = (r|s)|t    “或”的可结合律<br>3、 (rs)t = r(st)        “连接”的可结合律<br>4、 r(s|t) = rs|rt<br>(s|t)r = sr|tr               分配律<br>5、 εr = r, rε = r        ε是“连接”的恒等元素<br>6、 r|r = r<br>r* = ε|r|rr|…    “或”的抽取律</li></ul><h3 id="3-正规文法和正规式的等价变换"><a href="#3-正规文法和正规式的等价变换" class="headerlink" title="3.正规文法和正规式的等价变换"></a>3.正规文法和正规式的等价变换</h3><p>正规式 r , 存在一个G=(VN,VT,P,S) 使得 L(G) = L(r) ，反之亦然。</p><h4 id="1-将正规式转换成正规文法"><a href="#1-将正规式转换成正规文法" class="headerlink" title="1.将正规式转换成正规文法"></a>1.将正规式转换成正规文法</h4><ol><li>对形如  A -&gt; xy 的正规产生式：A -&gt; xB    B -&gt; y         </li><li>对形如A-&gt;x<code>*</code>y的正规产生式： A -&gt; xA    A -&gt; y                         </li><li>对形如A-&gt;x|y的正规产生式:   A -&gt; x        A -&gt; y<br>不断应用上述规则做变换，直到每个产生式最多含一个终结符。</li></ol><h4 id="2-将正规文法转换成正规式"><a href="#2-将正规文法转换成正规式" class="headerlink" title="2.将正规文法转换成正规式"></a>2.将正规文法转换成正规式</h4><p>文法产生式            正规式</p><ol><li>A -&gt; xB,B -&gt; y    ==  A = xy </li><li>A -&gt; xA|y        ==  A = x<code>*</code>y</li><li>A -&gt; x|y            ==  A = x|y</li></ol><h3 id="4-有穷自动机"><a href="#4-有穷自动机" class="headerlink" title="4.有穷自动机"></a>4.有穷自动机</h3><h4 id="1-DFA定义"><a href="#1-DFA定义" class="headerlink" title="1.DFA定义"></a>1.DFA定义</h4><ul><li><code>DFA</code>定义：一个确定的有穷自动机（DFA）M是一个五元组：M=（K，Σ，f，S，Z）其中:<ol><li>K 是一个有穷集，状态集,它的每个元素称为一个状态；</li><li>Σ 是一个有穷字母表，它的每个元素称为一个输入符号，所以也称Σ为输入符号表；</li><li>f 是转换函数，是在 K×Σ→K 上的映射，即，如f（ki，a）=kj，（ki∈K，kj∈K）就意味着，当前状态为ki，输入符为 a 时，将转换为下一个状态 kj，我们把 kj 称作 ki 的一个后继状态；</li><li>S∈K 是唯一的一个初态；</li><li>Z∈K 是一个终态集，终态也称可接受状态或结束状态。</li></ol></li></ul><p>简单来说：<br>K: 非终态集合<br>Σ: 终态集合<br>f: 状态转换函数<br>S: 初态（唯一）<br>Z： 终态集合</p><h4 id="2-NFA定义"><a href="#2-NFA定义" class="headerlink" title="2.NFA定义"></a>2.NFA定义</h4><ul><li>定义(不确定发有穷自动机)<ul><li>N = (K，Σ，f，S，Z)，其中：<br>K为状态的有穷非空集，<br>Σ 为有穷输入字母表，<br>f为映射函数，f: KxΣ*  → 2K，<br>S∈K是初始状态集，<br>Z∈K为终止状态集。</li></ul></li></ul><h4 id="3-NFA的确定化"><a href="#3-NFA的确定化" class="headerlink" title="3.NFA的确定化"></a>3.NFA的确定化</h4><p>DFA是NFA的特例.对每个DFA   M一定存在一个NFA  Ｍ’ ，使得  L(M)=L(M ‘)。</p><p>对每个NFA M存在着与之等价的DFA  M ‘ 。与某一NFA等价的DFA不唯一。</p><pre><code>1. 状态集合 I 的 ε-闭包,表示为ε-closure(I), 定义为一状态集, 是状态集I中的任何状态R经任意条ε弧而能到达的状态的集合。 状态集合I的任何状态R都属于 ε-closure(I)。2. 状态集合 I 的 a 弧转换，表示为 move(I,a) 定义为状态集合 J，其中 J 是所有那些可从 I 的某一状态经过一条 a 弧而到达的状态的全体。3. 定义：Ia  =  ε-closure(J)，其中：J= move(I,a) </code></pre><h4 id="4-DFA最小化"><a href="#4-DFA最小化" class="headerlink" title="4.DFA最小化"></a>4.DFA最小化</h4><ul><li>最小状态DFA<ul><li>没有多余状态(死状态、不可达状态)</li><li>没有两个状态是互相等价（不可区别）</li></ul></li><li>两个状态s和t等价：满足<ul><li>一致性——同是终态或同是非终态</li><li>蔓延性——从s出发读入某个a(a∈Σ)和从               t出发读入某个a到达的状态等价。</li></ul></li></ul><ol><li><p>先读出所有的终结符与非终结符</p></li><li><p>一步步划分等价的非终结符，直到无法划分即可</p></li><li><p>根据划分后的非终结符集合画出<code>DFA</code></p></li></ol><h2 id="3-自顶向下语法分析方法"><a href="#3-自顶向下语法分析方法" class="headerlink" title="3.自顶向下语法分析方法"></a>3.自顶向下语法分析方法</h2><ul><li>确定的自顶向下分析思想</li><li>LL(1)文法的判别</li><li>某些非LL(1)文法到LL(1)文法的等价变换</li><li>不确定的自顶向下分析思想</li><li>确定的自顶向下分析方法</li></ul><h3 id="1-文法分析"><a href="#1-文法分析" class="headerlink" title="1.文法分析"></a>1.文法分析</h3><ol><li><p>First集: 非终结符可以推到的第一个<code>终态集合</code></p></li><li><p>Follow集: 非终结符的下一位，如果推到终结符，则写入，如果推出空集则写入<code>#</code></p><pre><code>对于 A→α             A→β其中A∈VN ,  α, β ∈VN*当α和β不同时推导出空时（设 α不推导出空，β推导出空），则当FIRST(α)∩(FIRST(β)∪FOLLOW(A)) = Φ 时，对于非终结符A的替换仍可唯一地 确定候选。</code></pre></li><li><p>Select集: 当该产生式右部不为空，则相当于First集  当为空时相当于First集 U Follow集  (合并)</p></li></ol><h3 id="2-LL-1-文法的充要条件"><a href="#2-LL-1-文法的充要条件" class="headerlink" title="2.LL(1)文法的充要条件"></a>2.LL(1)文法的充要条件</h3><p>对每个非终结符A的两个不同产生式A→α和A→β，满足SELECT(A→α)∩SELECT(A→β)=Φ其中α,β不能同时  (<code>*</code>)=&gt;  ε</p><h3 id="3-非LL-1-到LL（1）转换"><a href="#3-非LL-1-到LL（1）转换" class="headerlink" title="3.非LL(1)到LL（1）转换"></a>3.非LL(1)到LL（1）转换</h3><ul><li>提取左公共因子</li><li>消除左递归</li></ul><h4 id="1-提取左公共因子"><a href="#1-提取左公共因子" class="headerlink" title="1.提取左公共因子"></a>1.提取左公共因子</h4><ul><li><p>A→αβ|αγ导致SELECT(A→αβ)∩ SELECT(A→αγ)≠Φ，因此是非LL(1)文法。</p></li><li><p>等价变换为A→α(β|γ)，然后：A→αA ‘                          A’ → β|γ</p></li><li><p>A→αβ1|αβ2|…|αβn |δ1|…| …|δm变换为: A→αA’ |δ1|…| …|δm     A’ → β1|β2|…|βn</p></li></ul><p>如：</p><pre class=" language-文法"><code class="language-文法">G1[S] 为:S→aSbS→aSS→ε化为：S→aS(b|ε)S→ε进一步化为：S→aSAS→ε A→bA→ε</code></pre><ul><li>不一定每个文法的左公共因子都能在有限的步骤内替换成无左公共因子的文法，文法中不含左公共因子只是LL(1)文法的必要条件。</li></ul><h4 id="2-消除左递归"><a href="#2-消除左递归" class="headerlink" title="2.消除左递归"></a>2.消除左递归</h4><ol><li><p>直接左递归：<br>A→Aβ<br>A∈VN, β ∈V*</p></li><li><p>间接左递归：<br>A→Bβ<br>B→Aα<br>A, B∈VN,  α, β ∈V*</p></li></ol><h5 id="1-消除直接左递归"><a href="#1-消除直接左递归" class="headerlink" title="1.消除直接左递归"></a>1.消除直接左递归</h5><p>把直接左递归改写为右递归。<br>如G5:<br>S→Sa<br>S→b<br>(L={ban|n≥0})<br>改为：<br>S→bS’<br>S’→aS’|ε</p><p>1.将无直接左递归的产生式改写成如：S→bS’</p><p>2.写出产生式S’,将有直接左递归的产生式改写成如： S’→aS’|ε    （最后添加ε）</p><pre class=" language-左递归"><code class="language-左递归">消除直接左递归的一般方法：A→Aα1| Aα2|…| Aαm|β1|β2|…|βn  其中： αi 不等于ε ， βj不以A开头。 改为：  A→ β1A'| β2A' |…| βnA'   A'→ α1A' | α2A' |…| αmA' |ε</code></pre><h5 id="2-消除间接左递归"><a href="#2-消除间接左递归" class="headerlink" title="2.消除间接左递归"></a>2.消除间接左递归</h5><ul><li>将间接左递归变为直接左递归，然后消除直接左递归。</li></ul><h3 id="4-文法化简"><a href="#4-文法化简" class="headerlink" title="4.文法化简"></a>4.文法化简</h3><p>如：</p><pre class=" language-例题"><code class="language-例题">化简文法 G[S] ： S → ASe | BCaD | aD | AC A → Cb | DBS C → bC | d B → Ac D → aD </code></pre><h2 id="LR-分析法"><a href="#LR-分析法" class="headerlink" title="LR(分析法)"></a>LR(分析法)</h2><p>LR(0)项目集规范族: 构成识别一个文法活前缀的DFA项目集（状态）的全体称为这个文法的LR(0)项目集规范族.</p><p>LR(0)文法：若其LR(0)项目集规范族不存在移进-归约，或归约-归约冲突，称为LR(0)文法。</p><h3 id="构造识别文法活前缀DFA的三种方法"><a href="#构造识别文法活前缀DFA的三种方法" class="headerlink" title="构造识别文法活前缀DFA的三种方法"></a>构造识别文法活前缀DFA的三种方法</h3><p>一、 根据形式定义求出活前缀的正规表达式，然后由此正规表达式构造NFA再确定化为DFA<br>二、 求出文法的所有项目，按一定规则构造识别活前缀的NFA再确定化为DFA<br>三、 使用闭包函数（CLOSURE）和转向函数(GOTO(I,X))构造文法G’的LR(0)的项目集规范族，再由转换函数建立状态之间的连接关系得到识别活前缀的DFA</p><ul><li>一个项目集可能包含多种项目<br>a) 移进和归约项目同时存在。移进-归约冲突<br>b) 归约和归约项目同时存在。归约-归约冲突</li></ul><h3 id="LR-0-分析表构造"><a href="#LR-0-分析表构造" class="headerlink" title="LR(0)分析表构造"></a>LR(0)分析表构造</h3><p>例子：E -&gt; aA   E -&gt; bB   A -&gt; cA    A -&gt; d  B -&gt; cB    B -&gt; d</p><ul><li><p>第一步：对文法G进行拓广，得其拓广文法G‘[S’]：</p><ol start="0"><li>S’ -&gt; E    </li><li>E -&gt; aA      </li><li>E -&gt; bB      </li><li>A -&gt; cA    </li><li>A -&gt; d         </li><li>B -&gt; cB       </li><li>B -&gt; d</li></ol></li><li><p>第二步：对拓广文法G‘[S’] ，构造出其LR(0)项目集规范簇I</p></li></ul><p><img src="https://res.cloudinary.com/valent/image/upload/v1591631943/Blog/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/2_g1auia.png" alt="项目集规范簇I"></p><ul><li>第三步：根据LR(0)项目集规范簇，构造出LR(0)分析表</li></ul><p><img src="https://res.cloudinary.com/valent/image/upload/v1591631943/Blog/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/3_enagna.png" alt="LR(0)分析表"></p><h3 id="SLR-1"><a href="#SLR-1" class="headerlink" title="SLR(1)"></a>SLR(1)</h3><p><img src="https://res.cloudinary.com/valent/image/upload/v1591632105/Blog/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/4_og3x8z.png" alt="SLR(1)"></p><h1 id="4-编译程序与解释程序"><a href="#4-编译程序与解释程序" class="headerlink" title="4.编译程序与解释程序"></a>4.编译程序与解释程序</h1><ol><li><p>主要区别： 解释程序与编译程序的主要区别: 不产生目标程序</p></li><li><p>在编译程序的设计中，<code>中间代码</code>生成和优化功能并不是必须的</p></li><li><p>编译程序的实现与具体的机器有关，与具体的语言也是有关的。</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编译原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python学习</title>
      <link href="/2020/06/04/python-xue-xi/"/>
      <url>/2020/06/04/python-xue-xi/</url>
      
        <content type="html"><![CDATA[<h1 id="Python-Tkinter"><a href="#Python-Tkinter" class="headerlink" title="Python Tkinter"></a>Python Tkinter</h1><p>Python 提供了多个图形开发界面的库，几个常用 Python GUI 库如下：</p><ul><li><p>Tkinter： <code>Tkinter</code> 模块(Tk 接口)是 Python 的标准 Tk GUI 工具包的接口 .Tk 和 Tkinter 可以在大多数的 Unix 平台下使用,同样可以应用在 Windows 和 Macintosh 系统里。Tk8.0 的后续版本可以实现本地窗口风格,并良好地运行在绝大多数平台中。</p></li><li><p>wxPython：<code>wxPython</code> 是一款开源软件，是 Python 语言的一套优秀的 GUI 图形库，允许 Python 程序员很方便的创建完整的、功能健全的 GUI 用户界面。</p></li><li><p>Jython：<code>Jython</code> 程序可以和 Java 无缝集成。除了一些标准模块，Jython 使用 Java 的模块。Jython 几乎拥有标准的Python 中不依赖于 C 语言的全部模块。比如，Jython 的用户界面将使用 Swing，AWT或者 SWT。Jython 可以被动态或静态地编译成 Java 字节码。</p></li></ul><h3 id="1-Tkinter编程"><a href="#1-Tkinter编程" class="headerlink" title="1.Tkinter编程"></a>1.Tkinter编程</h3><p>grid(row= ,column= ，columnspan= ,rowspan= )<br>代表的是占据几行，几列,总共占据几列,总共占据几行</p><p>str(二元组) 将二元组变成字符串</p>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> 编程 </tag>
            
            <tag> Tkinter </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Markdown</title>
      <link href="/2020/06/02/markdown/"/>
      <url>/2020/06/02/markdown/</url>
      
        <content type="html"><![CDATA[<center><h1 id="1-Markdown标题"><a href="#1-Markdown标题" class="headerlink" title="1.Markdown标题"></a>1.Markdown标题</h1></center><p><code>Markdown</code>标题有两种格式</p><h3 id="1-使用-和-标记一级和二级标题"><a href="#1-使用-和-标记一级和二级标题" class="headerlink" title="1.使用 = 和 - 标记一级和二级标题"></a>1.使用 = 和 - 标记一级和二级标题</h3><p>= 和 - 标记语法格式如下：</p><pre class=" language-md"><code class="language-md">我展示的是一级标题=================我展示的是二级标题-----------------</code></pre><p>效果如下：</p><h1 id="我展示的是一级标题"><a href="#我展示的是一级标题" class="headerlink" title="我展示的是一级标题"></a>我展示的是一级标题</h1><h2 id="我展示的是二级标题"><a href="#我展示的是二级标题" class="headerlink" title="我展示的是二级标题"></a>我展示的是二级标题</h2><h3 id="2-的使用"><a href="#2-的使用" class="headerlink" title="2.#的使用"></a>2.<code>#</code>的使用</h3><p>使用 <code>#</code>号可表示 1-6 级标题，一级标题对应一个 # 号，二级标题对应两个 # 号，以此类推。</p><pre class=" language-md"><code class="language-md"># 一级标题## 二级标题### 三级标题#### 四级标题##### 五级标题###### 六级标题</code></pre><p>效果如下：</p><center><h1 id="一级标题"><a href="#一级标题" class="headerlink" title="一级标题"></a>一级标题</h1><h2 id="二级标题"><a href="#二级标题" class="headerlink" title="二级标题"></a>二级标题</h2><h3 id="三级标题"><a href="#三级标题" class="headerlink" title="三级标题"></a>三级标题</h3><h4 id="四级标题"><a href="#四级标题" class="headerlink" title="四级标题"></a>四级标题</h4><h5 id="五级标题"><a href="#五级标题" class="headerlink" title="五级标题"></a>五级标题</h5><h6 id="六级标题"><a href="#六级标题" class="headerlink" title="六级标题"></a>六级标题</h6></center><hr><center><h1 id="2-Markdown字体"><a href="#2-Markdown字体" class="headerlink" title="2.Markdown字体"></a>2.Markdown字体</h1></center><h3 id="1-Markdown-段落"><a href="#1-Markdown-段落" class="headerlink" title="1. Markdown 段落"></a>1. Markdown 段落</h3><p>没有特殊的格式，直接编写文字就好，段落的换行是使用两个以上空格加上回车。</p><pre class=" language-md"><code class="language-md">无特殊格式  </code></pre><h3 id="2-Markdown字体："><a href="#2-Markdown字体：" class="headerlink" title="2. Markdown字体："></a>2. Markdown字体：</h3><pre class=" language-md"><code class="language-md">*斜体文本*_斜体文本_**粗体文本**__粗体文本__***粗斜体文本***___粗斜体文本___</code></pre><p>效果如下:  </p><center><p><em>斜体文本</em><br><em>斜体文本</em><br><strong>粗体文本</strong><br><strong>粗体文本</strong><br><strong><em>粗斜体文本</em></strong><br><strong><em>粗斜体文本</em></strong></p></center><h3 id="3-分割线"><a href="#3-分割线" class="headerlink" title="3. 分割线"></a>3. 分割线</h3><p>可以在一行中用三个以上的星号、减号、底线来建立一个分隔线，行内不能有其他东西。你也可以在星号或是减号中间插入空格。下面每种写法都可以建立分隔线：</p><p><code>* * *</code><br><code>*****</code><br><code>- - - -</code><br><code>----------</code></p><p>效果如下： </p><hr><hr><hr><hr><hr><h3 id="4-删除线"><a href="#4-删除线" class="headerlink" title="4. 删除线"></a>4. 删除线</h3><p>如果段落上的文字要添加删除线，只需要在文字的两端加上两个波浪线<code>~~</code> 即可，实例如下：</p><pre class=" language-md"><code class="language-md">删除线~~删除线~~~</code></pre><p>效果如下：</p><p>删除线<br><del>删除线</del></p><h3 id="5-下划线"><a href="#5-下划线" class="headerlink" title="5. 下划线"></a>5. 下划线</h3><p>下划线可以通过 HTML 的 <code>&lt;u&gt;</code> 标签来实现：</p><pre class=" language-md"><code class="language-md"><u>下划线</u></code></pre><p>效果如下：</p><center><u>下划线</u></center><hr><center><h1 id="3-Markdown列表"><a href="#3-Markdown列表" class="headerlink" title="3.Markdown列表"></a>3.Markdown列表</h1></center><p>Markdown 支持有序列表和无序列表。</p><p>无序列表使用星号(<code>*</code>)、加号(<code>+</code>)或是减号(<code>-</code>)作为列表标记：</p><pre class=" language-md"><code class="language-md">* 第一项* 第二项* 第三项+ 第一项+ 第二项+ 第三项- 第一项- 第二项- 第三项</code></pre><p>效果如下：</p><ul><li>第一项</li><li>第二项</li><li>第三项</li></ul><ul><li>第一项</li><li>第二项</li><li>第三项</li></ul><ul><li>第一项</li><li>第二项</li><li>第三项</li></ul><p>有序列表使用数字并加上 <code>.</code> 号来表示，如：</p><pre class=" language-md"><code class="language-md">1. 第一项2. 第二项3. 第三项</code></pre><p>效果如下： </p><ol><li>第一项</li><li>第二项</li><li>第三项</li></ol><hr><center><h1 id="4-Markdown区块"><a href="#4-Markdown区块" class="headerlink" title="4.Markdown区块"></a>4.Markdown区块</h1></center><p>Markdown 区块引用是在段落开头使用 <code>&gt;</code> 符号 ，然后后面紧跟一个空格符号：</p><pre class=" language-md"><code class="language-md">> 区块一>> 区块二>>> 区块三</code></pre><p>效果如下：</p><blockquote><p>区块一</p><blockquote><p>区块二</p><blockquote><p>区块三</p></blockquote></blockquote></blockquote><hr><center><h1 id="5-Markdown代码"><a href="#5-Markdown代码" class="headerlink" title="5.Markdown代码"></a>5.Markdown代码</h1></center><p>如果是段落上的一个函数或片段的代码可以用反引号把它包起来(`)，例如：</p><pre class=" language-md"><code class="language-md">`main()`函数</code></pre><p>效果如下：<br><code>main()</code>函数</p><p>也可以用 ``` 包裹一段代码，并指定一种语言（也可以不指定）：  </p><pre class=" language-md"><code class="language-md">### 三级目录#### 四级目录</code></pre><hr><center><h1 id="6-Markdown链接"><a href="#6-Markdown链接" class="headerlink" title="6.Markdown链接"></a>6.Markdown链接</h1></center><h3 id="1-一般链接使用"><a href="#1-一般链接使用" class="headerlink" title="1.一般链接使用"></a>1.一般链接使用</h3><p>使用方法：</p><pre class=" language-md"><code class="language-md">[链接名](链接地址)或<链接地址>[sublime](https://www.sublimetext.com/3)  <https://www.sublimetext.com/3></code></pre><p>效果如下：</p><p><a href="https://www.sublimetext.com/3" target="_blank" rel="noopener">sublime</a>  </p><p><a href="https://www.sublimetext.com/3" target="_blank" rel="noopener">https://www.sublimetext.com/3</a></p><h3 id="2-高级链接使用"><a href="#2-高级链接使用" class="headerlink" title="2.高级链接使用"></a>2.高级链接使用</h3><p>可以通过变量来设置一个链接，变量赋值在文档末尾进行：</p><pre class=" language-md"><code class="language-md">链接使用a为变量[sublime][a][a]: https://www.sublimetext.com/3</code></pre><p>效果如下：<br>链接使用a为变量<a href="https://www.sublimetext.com/3" target="_blank" rel="noopener">sublime</a></p><hr><center><h1 id="7-Markdown图片"><a href="#7-Markdown图片" class="headerlink" title="7.Markdown图片"></a>7.Markdown图片</h1></center><p>图片一般语法为：</p><pre class=" language-md"><code class="language-md">![图片的代替文字](图片地址)</code></pre><p>效果如下：</p><p><img src="https://res.cloudinary.com/valent/image/upload/v1566550076/Blog/Background/5d2853e0e4d36_kxs5k4.jpg" alt="图片的代替文字"></p><p>也可以像网址那样对图片网址使用变量:</p><pre class=" language-md"><code class="language-md">图片的代替文字[图片的代替文字][图片地址][图片地址]: https://res.cloudinary.com/valent/image/upload/v1566550076/Blog/Background/5d2853e0e4d36_kxs5k4.jpg</code></pre><p>效果如下：</p><p>图片的代替文字<a href="https://res.cloudinary.com/valent/image/upload/v1566550076/Blog/Background/5d2853e0e4d36_kxs5k4.jpg" target="_blank" rel="noopener">图片的代替文字</a></p><hr><center><h1 id="8-Markdown表格"><a href="#8-Markdown表格" class="headerlink" title="8.Markdown表格"></a>8.Markdown表格</h1></center>Markdown 制作表格使用 `|` 来分隔不同的单元格，使用 `-` 来分隔表头和其他行。<p>语法格式如下：</p><pre class=" language-md"><code class="language-md">|  人物   | 评级  | 技能 ||  ----  | ----  | ---- || 吕布  | SSS | 战神附体 || 关羽  | SS | 战马冲锋 |</code></pre><p>效果如下：</p><table><thead><tr><th>人物</th><th>评级</th><th>技能</th></tr></thead><tbody><tr><td>吕布</td><td>SSS</td><td>战神附体</td></tr><tr><td>关羽</td><td>SS</td><td>战马冲锋</td></tr></tbody></table><p>对齐方式</p><p>我们可以设置表格的对齐方式：</p><ul><li>-: 设置内容和标题栏居右对齐。</li><li>:- 设置内容和标题栏居左对齐。</li><li>:-: 设置内容和标题栏居中对齐。</li></ul><hr><center><h1 id="8-Markdown其它"><a href="#8-Markdown其它" class="headerlink" title="8.Markdown其它"></a>8.Markdown其它</h1></center><h3 id="1-转义"><a href="#1-转义" class="headerlink" title="1.转义"></a>1.转义</h3><p>Markdown 使用了很多特殊符号来表示特定的意义，如果需要显示特定的符号则需要使用转义字符，Markdown 使用反斜杠转义特殊字符</p><pre class=" language-md"><code class="language-md">**文本加粗** \*\* 正常显示星号 \*\*</code></pre><p>效果如下：</p><p><strong>文本加粗</strong><br>** 正常显示星号 **</p><p>Markdown 支持以下这些符号前面加上反斜杠来帮助插入普通的符号：</p><pre class=" language-md"><code class="language-md">\   反斜线`   反引号*   星号_   下划线{}  花括号[]  方括号()  小括号#   井字号+   加号-   减号.   英文句点!   感叹号</code></pre><p>效果如下：<br>\   反斜线<br>`   反引号</p><ul><li>星号<br>_   下划线<br>{}  花括号<br>[]  方括号<br>()  小括号<h1 id="井字号"><a href="#井字号" class="headerlink" title="井字号"></a>井字号</h1></li></ul><ul><li>加号</li></ul><ul><li>减号<br>.   英文句点<br>!   感叹号</li></ul><h3 id="2-公式"><a href="#2-公式" class="headerlink" title="2.公式"></a>2.公式</h3><p>加载 Mathjax 对数学公式进行渲染：</p><pre class=" language-md"><code class="language-md">$$\mathbf{V}_1 \times \mathbf{V}_2 =  \begin{vmatrix} \mathbf{i} & \mathbf{j} & \mathbf{k} \\\frac{\partial X}{\partial u} &  \frac{\partial Y}{\partial u} & 0 \\\frac{\partial X}{\partial v} &  \frac{\partial Y}{\partial v} & 0 \\\end{vmatrix}${$tep1}{\style{visibility:hidden}{(x+1)(x+1)}}$$</code></pre><p>效果如下：</p><p>$$<br>\mathbf{V}_1 \times \mathbf{V}_2 =  \begin{vmatrix}<br>\mathbf{i} &amp; \mathbf{j} &amp; \mathbf{k} \<br>\frac{\partial X}{\partial u} &amp;  \frac{\partial Y}{\partial u} &amp; 0 \<br>\frac{\partial X}{\partial v} &amp;  \frac{\partial Y}{\partial v} &amp; 0 \<br>\end{vmatrix}<br>${$tep1}{\style{visibility:hidden}{(x+1)(x+1)}}<br>$$</p>]]></content>
      
      
      <categories>
          
          <category> 教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MD </tag>
            
            <tag> 教程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>matery魔改</title>
      <link href="/2020/06/02/matery-mo-gai/"/>
      <url>/2020/06/02/matery-mo-gai/</url>
      
        <content type="html"><![CDATA[<blockquote><p>主题魔改</p></blockquote><h3 id="1-添加天气插件"><a href="#1-添加天气插件" class="headerlink" title="1.添加天气插件"></a>1.添加天气插件</h3><p>进入<a href="https://cj.weather.com.cn/plugin/pc" target="_blank" rel="noopener">中国天气网</a>来定制自己的插件</p><p>自定义之后选择<code>生成代码</code>，生成如下一段代码</p><p>效果如下<br><img src="https://cdn.jsdelivr.net/gh/Emperortino/CDN2/img/Blog/matery/1.png" alt="效果图"></p><p>将定制好后的代码复制到themes/matery/layout/layout.ejs即可</p><h3 id="2-修改代码块样式"><a href="#2-修改代码块样式" class="headerlink" title="2.修改代码块样式"></a>2.修改代码块样式</h3><p>自定义自己的代码块间的样式，按<code>F12</code>，先在网页上进行调试，直到自己满意再复制粘贴到相应的文件中</p><ol><li>CSS添加选择器 <code>hover</code><br>当鼠标经过，自动变幻<pre class=" language-css"><code class="language-css"><span class="token selector">code<span class="token pseudo-class">:hover</span> </span><span class="token punctuation">{</span><span class="token property">color</span><span class="token punctuation">:</span> <span class="token hexcode">#d2cc14</span><span class="token punctuation">;</span><span class="token property">background-color</span><span class="token punctuation">:</span> <span class="token hexcode">#ffe20f</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre></li></ol><h3 id="3-添加樱花效果"><a href="#3-添加樱花效果" class="headerlink" title="3.添加樱花效果"></a>3.添加樱花效果</h3><p>在<code>layout.ejs</code>导入</p><pre class=" language-js"><code class="language-js"><span class="token operator">&lt;</span><span class="token operator">!</span><span class="token operator">--</span>樱花特效<span class="token operator">--</span><span class="token operator">-</span><span class="token operator">></span>    <span class="token operator">&lt;</span>script type<span class="token operator">=</span><span class="token string">"text/javascript"</span> src<span class="token operator">=</span><span class="token string">"https://cdn.jsdelivr.net/gh/Emperortino/CDN2/js/cool/sakura.js"</span><span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">></span></code></pre><p>也可以自己下载下来保存，然后在<code>src</code>后面写入自己的路径</p><h3 id="4-文章末尾添加结束标记"><a href="#4-文章末尾添加结束标记" class="headerlink" title="4.文章末尾添加结束标记"></a>4.文章末尾添加结束标记</h3><p>效果如下：<br><img src="" alt=""></p><p>新建布局文件<code>post-end-tag.swig</code>，添加代码如下：</p><pre class=" language-themes\matery\layout\_macro\post-end-tag.swig"><code class="language-themes\matery\layout\_macro\post-end-tag.swig"><div>  {% if not is_index %}    <div style="text-align:center;color:#bfbfbf;font-size:16px;">      <span>-------- 本文结束 </span>      <i class="fa fa-{{ config.post_end_tag.icon }}"></i>      <span> 感谢阅读 --------</span>    </div>  {% endif %}</div></code></pre><p>在文章布局中添加如下：</p><pre class=" language-themes\matery\layout\post.ejs"><code class="language-themes\matery\layout\post.ejs">{% if config.post_end_tag.enabled and not is_index %}  <div>   {% include 'post-end-tag.swig' %}  </div>{% endif %}</code></pre><p>最后在站点配置文件中添加如下：</p><pre class=" language-_config.yml"><code class="language-_config.yml">post_end_tag:  enabled: true  # 是否开启文末的本文结束标记  icon: paw # 结束标记之间的图标</code></pre><p>重启服务器：</p><pre class=" language-Hexo"><code class="language-Hexo">执行：hexo clean hexo ghexo s</code></pre><h3 id="5-个性化回到顶部"><a href="#5-个性化回到顶部" class="headerlink" title="5.个性化回到顶部"></a>5.个性化回到顶部</h3><p>打开主题的layout文件夹中的layout.ejs文件，添加代码:</p><pre class=" language-css"><code class="language-css">&lt;!-- 上吊猫 -->&lt;div class=<span class="token string">"back-to-top cd-top faa-float animated cd-is-visible"</span> style=<span class="token string">"top: -900px;"</span>>&lt;/div>&lt;link rel=<span class="token string">"stylesheet"</span> type=<span class="token string">"text/css"</span> href=<span class="token string">"https://cdn.jsdelivr.net/gh/Emperortino/CDN2/fun/back-top/css/top.css"</span> />&lt;script type=<span class="token string">"text/javascript"</span> src=<span class="token string">"https://cdn.jsdelivr.net/gh/Emperortino/CDN2/fun/back-top/js/top.js"</span>>&lt;/script> </code></pre><h3 id="6-修改顶部菜单栏"><a href="#6-修改顶部菜单栏" class="headerlink" title="6.修改顶部菜单栏"></a>6.修改顶部菜单栏</h3><ol><li>不移动时隐藏菜单栏<br>```<br>header .nav-transparent {<br> background-color: transparent !important;<br> background-image: none;<br> box-shadow: none;</li></ol><ul><li>display: none;<br>}<br>```</li></ul>]]></content>
      
      
      <categories>
          
          <category> Hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 主题 </tag>
            
            <tag> hexo </tag>
            
            <tag> 魔改 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Sublime</title>
      <link href="/2020/06/02/sublime/"/>
      <url>/2020/06/02/sublime/</url>
      
        <content type="html"><![CDATA[<h1 id="Sublime3-安装-破解-使用"><a href="#Sublime3-安装-破解-使用" class="headerlink" title="Sublime3 安装,破解,使用"></a>Sublime3 安装,破解,使用</h1><h2 id="1：-sublime下载"><a href="#1：-sublime下载" class="headerlink" title="1： sublime下载"></a>1： sublime下载</h2><p> 进入官网,下载<a href="https://www.sublimetext.com/3" target="_blank" rel="noopener">sublime</a>  </p><h2 id="2：-sublime破解"><a href="#2：-sublime破解" class="headerlink" title="2： sublime破解"></a>2： sublime破解</h2><ol><li><p>安装完成后，打开<code>Sublime</code></p></li><li><p>打开侧边栏：Help -&gt; Enter Lincense 输入以下许可证（3.2.1 目前我正在使用的这个注册码）</p></li></ol><pre class=" language-bash"><code class="language-bash">ZYNGA INC.50 User LicenseEA7E-811825927BA117 84C9300F 4A0CCBC4 34A56B44985E4562 59F2B63B CCCFF92F 0E646B830FD6487D 1507AE29 9CC4F9F5 0A6F32E30343D868 C18E2CD5 27641A71 25475648309705B3 E468DDC4 1B766A18 7952D28CE627DDBA 960A2153 69A2D98A C87C060745DC6049 8C04EC29 D18DFA40 442C680B1342224D 44D90641 33A3B9F2 46AADB8F</code></pre><ol start="3"><li>激活完成后显示(表明激活成功！！！)<br><img src="https://res.cloudinary.com/valent/image/upload/v1566374585/Blog/Sublime/sublime1_scajls.png" alt=""></li></ol><h2 id="3、安装Package-Control"><a href="#3、安装Package-Control" class="headerlink" title="3、安装Package Control"></a>3、安装Package Control</h2><p>   <code>Package Control</code>为插件管理包，所以我们首先要安装它。有了它，我们就可以很方便的浏览、安装和卸载Sublime Text中的插件。</p><ul><li>方法一<br>通过快捷键或者View &gt; Show Console菜单打开控制台，复制粘贴如下代码回车即可。</li></ul><pre class=" language-bash"><code class="language-bash"><span class="token function">import</span> urllib.request,os,hashlib<span class="token punctuation">;</span> h <span class="token operator">=</span> <span class="token string">'6f4c264a24d933ce70df5dedcf1dcaee'</span> + <span class="token string">'ebe013ee18cced0ef93d5f746d80ef60'</span><span class="token punctuation">;</span> pf <span class="token operator">=</span> <span class="token string">'Package Control.sublime-package'</span><span class="token punctuation">;</span> ipp <span class="token operator">=</span> sublime.installed_packages_path<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> urllib.request.install_opener<span class="token punctuation">(</span> urllib.request.build_opener<span class="token punctuation">(</span> urllib.request.ProxyHandler<span class="token punctuation">(</span><span class="token punctuation">))</span> <span class="token punctuation">)</span><span class="token punctuation">;</span> by <span class="token operator">=</span> urllib.request.urlopen<span class="token punctuation">(</span> <span class="token string">'http://packagecontrol.io/'</span> + pf.replace<span class="token punctuation">(</span><span class="token string">' '</span>, <span class="token string">'%20'</span><span class="token punctuation">))</span>.read<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> dh <span class="token operator">=</span> hashlib.sha256<span class="token punctuation">(</span>by<span class="token punctuation">)</span>.hexdigest<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> print<span class="token punctuation">(</span><span class="token string">'Error validating download (got %s instead of %s), please try manual install'</span> % <span class="token punctuation">(</span>dh, h<span class="token punctuation">))</span> <span class="token keyword">if</span> dh <span class="token operator">!=</span> h <span class="token keyword">else</span> open<span class="token punctuation">(</span>os.path.join<span class="token punctuation">(</span> ipp, pf<span class="token punctuation">)</span>, <span class="token string">'wb'</span> <span class="token punctuation">)</span>.write<span class="token punctuation">(</span>by<span class="token punctuation">)</span></code></pre><ul><li><p>方法二：Package Control源文件下载</p><p> 下载地址：<a href="https://github.com/wbond/package_control" target="_blank" rel="noopener"><code>package contro</code></a>  </p><p> 点击右上角的Clone or download按钮，然后选择Download ZIP</p><p> <img src="https://cdn.jsdelivr.net/gh/Emperortino/CDN2/img/sublime/1.png" alt="down"></p></li></ul><p>   1.将下载的ZIP文件解压，并重命名为Package Control，未重命名或重命名错误则会出现如下错误提示</p><p>   <img src="https://res.cloudinary.com/valent/image/upload/v1566376245/Blog/Sublime/sublime3_ubv9r9.png" alt=""></p><p>   2.在菜单栏中点击Preferences &gt; Browe Packages…，打开一个文件夹，复制刚才的Package Control文件至此目录下。</p><p>   <img src="https://cdn.jsdelivr.net/gh/Emperortino/CDN2/img/sublime/2.png" alt="安装"></p><p>   3.在菜单中点击Preferences，若出现Package Settings和package control选项，就说明安装Package Control成功了。</p><p>   <img src="https://res.cloudinary.com/valent/image/upload/v1566376376/Blog/Sublime/sublime5_c42pqu.png" alt=""></p><h3 id="1：-package-control使用失败"><a href="#1：-package-control使用失败" class="headerlink" title="1： package control使用失败"></a>1： package control使用失败</h3><ol><li><p>打开<code>Settings-User</code><br><img src="https://cdn.jsdelivr.net/gh/Emperortino/CDN2/img/sublime/3.png" alt="User"></p></li><li><p>添加如下内容<br><img src="https://cdn.jsdelivr.net/gh/Emperortino/CDN2/img/sublime/4.png" alt="channels"></p></li><li><p>也可以将channel文件下载下来，下面的路径则变为自己文件所在的路径</p></li><li><p>在菜单中点击<code>Preferences</code>，若出现<code>Package Settings</code>和<code>package control</code>选项，就说明安装<code>Package Control</code>成功了。</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 破解 </tag>
            
            <tag> sublime </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法设计与分析（二）</title>
      <link href="/2020/06/01/suan-fa-she-ji-yu-fen-xi-er/"/>
      <url>/2020/06/01/suan-fa-she-ji-yu-fen-xi-er/</url>
      
        <content type="html"><![CDATA[<blockquote><p>算法与设计学习过程<br>坚持更新（使用JAVA语言）</p></blockquote><h1 id="递归算法求解矩阵连乘"><a href="#递归算法求解矩阵连乘" class="headerlink" title="递归算法求解矩阵连乘"></a>递归算法求解矩阵连乘</h1><pre class=" language-bash"><code class="language-bash">/******************** 递归算法求解 ********************/int MatrixChain_Recursive<span class="token punctuation">(</span>int i, int j, int *p, int **s<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">==</span> j<span class="token punctuation">)</span>        <span class="token keyword">return</span> 0<span class="token punctuation">;</span>    int u <span class="token operator">=</span> MatrixChain_Recursive<span class="token punctuation">(</span>i, i, p, s<span class="token punctuation">)</span> + MatrixChain_Recursive<span class="token punctuation">(</span>i + 1, j, p, s<span class="token punctuation">)</span> + p<span class="token punctuation">[</span>i - 1<span class="token punctuation">]</span> * p<span class="token punctuation">[</span>i<span class="token punctuation">]</span> * p<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>   s<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">=</span>i<span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>int k <span class="token operator">=</span> i+1<span class="token punctuation">;</span> k <span class="token operator">&lt;</span> j<span class="token punctuation">;</span> k++<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        int tmp <span class="token operator">=</span> MatrixChain_Recursive<span class="token punctuation">(</span>i, k, p, s<span class="token punctuation">)</span> + MatrixChain_Recursive<span class="token punctuation">(</span>k + 1, j, p, s<span class="token punctuation">)</span> + p<span class="token punctuation">[</span>i - 1<span class="token punctuation">]</span> * p<span class="token punctuation">[</span>k<span class="token punctuation">]</span> * p<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>tmp <span class="token operator">&lt;</span> u<span class="token punctuation">)</span>        <span class="token punctuation">{</span>            u <span class="token operator">=</span> tmp<span class="token punctuation">;</span>            s<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> k<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> u<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h1 id="动态规划算法"><a href="#动态规划算法" class="headerlink" title="动态规划算法"></a>动态规划算法</h1><pre class=" language-bash"><code class="language-bash">/******************** 动态规划算法 ********************/void MatrixChain_Dynamic<span class="token punctuation">(</span>int n, int *p, int **m, int **s<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>int i <span class="token operator">=</span> 1<span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> i++<span class="token punctuation">)</span>        m<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> 0<span class="token punctuation">;</span>             // l <span class="token operator">=</span> 1    <span class="token keyword">for</span> <span class="token punctuation">(</span>int r <span class="token operator">=</span> 2<span class="token punctuation">;</span> r <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> r++<span class="token punctuation">)</span> // l is the chain length, 自底向上！        <span class="token keyword">for</span> <span class="token punctuation">(</span>int i <span class="token operator">=</span> 1<span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n -r + 1<span class="token punctuation">;</span> i++<span class="token punctuation">)</span>        <span class="token punctuation">{</span>            int j <span class="token operator">=</span> r + i - 1<span class="token punctuation">;</span>            m<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> m<span class="token punctuation">[</span>i + 1<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> +p<span class="token punctuation">[</span>i-1<span class="token punctuation">]</span>*p<span class="token punctuation">[</span>i<span class="token punctuation">]</span>*p<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span> //i,j分别对应矩阵链的首尾            s<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> i<span class="token punctuation">;</span>                                                       // k <span class="token operator">=</span> i            <span class="token keyword">for</span> <span class="token punctuation">(</span>int k <span class="token operator">=</span> i + 1<span class="token punctuation">;</span> k <span class="token operator">&lt;</span> j<span class="token punctuation">;</span> k++<span class="token punctuation">)</span>            <span class="token punctuation">{</span>                int t <span class="token operator">=</span> m<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>k<span class="token punctuation">]</span> + m<span class="token punctuation">[</span>k + 1<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> + p<span class="token punctuation">[</span>i - 1<span class="token punctuation">]</span> * p<span class="token punctuation">[</span>k<span class="token punctuation">]</span> * p<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>t <span class="token operator">&lt;</span> m<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span>                <span class="token punctuation">{</span>                    m<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> t<span class="token punctuation">;</span>                    s<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> k<span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span></code></pre><h1 id="备忘录算法"><a href="#备忘录算法" class="headerlink" title="备忘录算法"></a>备忘录算法</h1><pre class=" language-bash"><code class="language-bash">/******************** 备忘录法 ********************/int LookupChain<span class="token punctuation">(</span>int i,int j,int *p,int **m,int **s<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>m<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">></span> 0<span class="token punctuation">)</span>        <span class="token keyword">return</span> m<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">==</span> j<span class="token punctuation">)</span>        <span class="token keyword">return</span> 0<span class="token punctuation">;</span>    int u <span class="token operator">=</span> LookupChain<span class="token punctuation">(</span>i, i, p, m, s<span class="token punctuation">)</span> + LookupChain<span class="token punctuation">(</span>i + 1, j, p, m, s<span class="token punctuation">)</span> + p<span class="token punctuation">[</span>i - 1<span class="token punctuation">]</span> * p<span class="token punctuation">[</span>i<span class="token punctuation">]</span> * p<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>    s<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">=</span>i<span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>int k <span class="token operator">=</span> i+1<span class="token punctuation">;</span> k <span class="token operator">&lt;</span> j<span class="token punctuation">;</span> k++<span class="token punctuation">)</span>    <span class="token punctuation">{</span>       int tmp <span class="token operator">=</span> LookupChain<span class="token punctuation">(</span>i, k, p, m, s<span class="token punctuation">)</span> + LookupChain<span class="token punctuation">(</span>k + 1, j, p, m, s<span class="token punctuation">)</span> + p<span class="token punctuation">[</span>i - 1<span class="token punctuation">]</span> * p<span class="token punctuation">[</span>k<span class="token punctuation">]</span> * p<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>tmp <span class="token operator">&lt;</span> u<span class="token punctuation">)</span>        <span class="token punctuation">{</span>            u <span class="token operator">=</span> tmp<span class="token punctuation">;</span>            s<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> k<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    m<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> u<span class="token punctuation">;</span>    <span class="token keyword">return</span> u<span class="token punctuation">;</span><span class="token punctuation">}</span>int MatrixChain_LookUp<span class="token punctuation">(</span>int i, int j, int n, int *p, int **m, int **s<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>int p <span class="token operator">=</span> 1<span class="token punctuation">;</span> p <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> p++<span class="token punctuation">)</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span>int q <span class="token operator">=</span> 1<span class="token punctuation">;</span> q <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> q++<span class="token punctuation">)</span>            m<span class="token punctuation">[</span>p<span class="token punctuation">]</span><span class="token punctuation">[</span>q<span class="token punctuation">]</span> <span class="token operator">=</span> 0<span class="token punctuation">;</span>    <span class="token keyword">return</span> LookupChain<span class="token punctuation">(</span>i, j, p, m, s<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h1 id="构造最优解算法"><a href="#构造最优解算法" class="headerlink" title="构造最优解算法"></a>构造最优解算法</h1><pre class=" language-bash"><code class="language-bash">/*****************************************构造最优解***********************************************************/void Traceback<span class="token punctuation">(</span>int i, int j, int **s<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">==</span> j<span class="token punctuation">)</span>        cout <span class="token operator">&lt;&lt;</span> <span class="token string">"A"</span><span class="token operator">&lt;&lt;</span>i<span class="token punctuation">;</span>    <span class="token keyword">else</span>    <span class="token punctuation">{</span>        cout <span class="token operator">&lt;&lt;</span> <span class="token string">"("</span><span class="token punctuation">;</span>        Traceback<span class="token punctuation">(</span>i, s<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span>, s<span class="token punctuation">)</span><span class="token punctuation">;</span>        Traceback<span class="token punctuation">(</span>s<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> + 1, j, s<span class="token punctuation">)</span><span class="token punctuation">;</span>        cout <span class="token operator">&lt;&lt;</span> <span class="token string">")"</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h1 id="主函数"><a href="#主函数" class="headerlink" title="主函数"></a>主函数</h1><pre class=" language-bash"><code class="language-bash">int main<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    int <span class="token keyword">select</span><span class="token punctuation">;</span>    int p<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span>30,35,15,5,10,20,25<span class="token punctuation">}</span><span class="token punctuation">;</span>    int n <span class="token operator">=</span> sizeof<span class="token punctuation">(</span>p<span class="token punctuation">)</span> / sizeof<span class="token punctuation">(</span>*p<span class="token punctuation">)</span> - 1<span class="token punctuation">;</span>    int **m <span class="token operator">=</span> new int *<span class="token punctuation">[</span>n + 1<span class="token punctuation">]</span><span class="token punctuation">;</span>    int **s <span class="token operator">=</span> new int *<span class="token punctuation">[</span>n + 1<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>int i <span class="token operator">=</span> 1<span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> i++<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        m<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> new int<span class="token punctuation">[</span>n + 1<span class="token punctuation">]</span><span class="token punctuation">;</span>        s<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> new int<span class="token punctuation">[</span>n + 1<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    printf<span class="token punctuation">(</span><span class="token string">"*********动态规划算法*****\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    printf<span class="token punctuation">(</span><span class="token string">"******1.动态规划算法******\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    printf<span class="token punctuation">(</span><span class="token string">"******2.递归算法*********\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    printf<span class="token punctuation">(</span><span class="token string">"******3.备忘录算法*******\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    printf<span class="token punctuation">(</span><span class="token string">"*******0.退出************\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    printf<span class="token punctuation">(</span><span class="token string">"*************************\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    printf<span class="token punctuation">(</span><span class="token string">"请选择："</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    scanf<span class="token punctuation">(</span><span class="token string">"%d"</span>,<span class="token operator">&amp;</span>select<span class="token punctuation">)</span><span class="token punctuation">;</span>    if<span class="token punctuation">(</span>select<span class="token operator">=</span>1<span class="token punctuation">)</span> <span class="token punctuation">{</span> /******************** 动态规划算法********************/    cout<span class="token operator">&lt;&lt;</span><span class="token string">"动态规划算法"</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>        cout <span class="token operator">&lt;&lt;</span> <span class="token string">"最优值为："</span><span class="token punctuation">;</span>         MatrixChain_Dynamic<span class="token punctuation">(</span>n, p, m, s<span class="token punctuation">)</span><span class="token punctuation">;</span>         cout <span class="token operator">&lt;&lt;</span> m<span class="token punctuation">[</span>1<span class="token punctuation">]</span><span class="token punctuation">[</span>n<span class="token punctuation">]</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>         cout <span class="token operator">&lt;&lt;</span> m<span class="token punctuation">[</span>2<span class="token punctuation">]</span><span class="token punctuation">[</span>5<span class="token punctuation">]</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">else</span> if<span class="token punctuation">(</span>select<span class="token operator">=</span>2<span class="token punctuation">)</span> <span class="token punctuation">{</span>        /******************** 递归算法求解 ********************/        cout<span class="token operator">&lt;&lt;</span><span class="token string">"递归算法求解"</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>        cout <span class="token operator">&lt;&lt;</span> <span class="token string">"最优值为："</span><span class="token punctuation">;</span>        cout <span class="token operator">&lt;&lt;</span> MatrixChain_Recursive<span class="token punctuation">(</span>1, n, p, s<span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>        cout <span class="token operator">&lt;&lt;</span> MatrixChain_Recursive<span class="token punctuation">(</span>2, 5, p, s<span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>select<span class="token operator">=</span>3<span class="token punctuation">)</span> <span class="token punctuation">{</span>            /******************** 备忘录算法 ********************/            cout<span class="token operator">&lt;&lt;</span><span class="token string">"备忘录算法"</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>            cout <span class="token operator">&lt;&lt;</span> <span class="token string">"最优值为："</span><span class="token punctuation">;</span>            cout <span class="token operator">&lt;&lt;</span> MatrixChain_LookUp<span class="token punctuation">(</span>1, n, n, p, m, s<span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>            cout <span class="token operator">&lt;&lt;</span> MatrixChain_LookUp<span class="token punctuation">(</span>2, 5, n, p, m, s<span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">else</span> if<span class="token punctuation">(</span>select<span class="token operator">=</span>0<span class="token punctuation">)</span><span class="token punctuation">{</span>            exit<span class="token punctuation">(</span>0<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    cout<span class="token operator">&lt;&lt;</span><span class="token string">"最优解为："</span><span class="token punctuation">;</span>    Traceback<span class="token punctuation">(</span>1, n, s<span class="token punctuation">)</span><span class="token punctuation">;</span>    cout <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>int i <span class="token operator">=</span> 1<span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> i++<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        delete<span class="token punctuation">[</span><span class="token punctuation">]</span> m<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>        delete<span class="token punctuation">[</span><span class="token punctuation">]</span> s<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    delete<span class="token punctuation">[</span><span class="token punctuation">]</span> m<span class="token punctuation">;</span>    delete<span class="token punctuation">[</span><span class="token punctuation">]</span> s<span class="token punctuation">;</span>    <span class="token keyword">return</span> 0<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><hr>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法设计与分析 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法设计与分析（一）</title>
      <link href="/2020/06/01/suan-fa-she-ji-yu-fen-xi-yi/"/>
      <url>/2020/06/01/suan-fa-she-ji-yu-fen-xi-yi/</url>
      
        <content type="html"><![CDATA[<blockquote><p>算法与设计学习过程<br>坚持更新（使用JAVA语言）</p></blockquote><h1 id="递归：实现汉诺塔问题"><a href="#递归：实现汉诺塔问题" class="headerlink" title="递归：实现汉诺塔问题"></a>递归：实现汉诺塔问题</h1><pre class=" language-bash"><code class="language-bash">public class Hannota <span class="token punctuation">{</span>    public static void main<span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        int N <span class="token operator">=</span> 3<span class="token punctuation">;</span>        Hanoi<span class="token punctuation">(</span><span class="token string">'A'</span>, <span class="token string">'B'</span>, <span class="token string">'C'</span>, N<span class="token punctuation">)</span><span class="token punctuation">;</span>      //使用    <span class="token punctuation">}</span>    public static void Hanoi<span class="token punctuation">(</span>char from, char inter, char to, int  N<span class="token punctuation">)</span> <span class="token punctuation">{</span>    //方法        <span class="token keyword">if</span> <span class="token punctuation">(</span>N <span class="token operator">==</span> 1<span class="token punctuation">)</span><span class="token punctuation">{</span>            System.out.println<span class="token punctuation">(</span><span class="token string">"移动 1 从 "</span>+ from + <span class="token string">" 到 "</span> + to<span class="token punctuation">)</span><span class="token punctuation">;</span>  //只有一个的情况下         <span class="token punctuation">}</span>else <span class="token punctuation">{</span>            Hanoi<span class="token punctuation">(</span> from, to, inter, N - 1<span class="token punctuation">)</span><span class="token punctuation">;</span>             System.out.println<span class="token punctuation">(</span><span class="token string">"移动 "</span> + N + <span class="token string">" 从 "</span> + from + <span class="token string">" 到 "</span> + to<span class="token punctuation">)</span><span class="token punctuation">;</span>                     Hanoi<span class="token punctuation">(</span> inter, from, to, N - 1<span class="token punctuation">)</span><span class="token punctuation">;</span>                 <span class="token punctuation">}</span>     <span class="token punctuation">}</span><span class="token punctuation">}</span>  </code></pre><h1 id="递归：实现排序问题"><a href="#递归：实现排序问题" class="headerlink" title="递归：实现排序问题"></a>递归：实现排序问题</h1><pre class=" language-bash"><code class="language-bash">public class Sort <span class="token punctuation">{</span>    public static int S<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> new int<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">{</span>1,2,3<span class="token punctuation">}</span><span class="token punctuation">;</span>    //定义一个数组s<span class="token punctuation">{</span>1,2,3<span class="token punctuation">}</span>    public static void main<span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        perm<span class="token punctuation">(</span>S,0,S.length-1<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    private static void swap<span class="token punctuation">(</span>int i1, int i2<span class="token punctuation">)</span> <span class="token punctuation">{</span>        int temp <span class="token operator">=</span> S<span class="token punctuation">[</span>i2<span class="token punctuation">]</span><span class="token punctuation">;</span>        S<span class="token punctuation">[</span>i2<span class="token punctuation">]</span> <span class="token operator">=</span> S<span class="token punctuation">[</span>i1<span class="token punctuation">]</span><span class="token punctuation">;</span>        S<span class="token punctuation">[</span>i1<span class="token punctuation">]</span> <span class="token operator">=</span> temp<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    public static void perm<span class="token punctuation">(</span>int arr<span class="token punctuation">[</span><span class="token punctuation">]</span>, int begin,int end<span class="token punctuation">)</span> <span class="token punctuation">{</span>        if<span class="token punctuation">(</span>end<span class="token operator">==</span>begin<span class="token punctuation">)</span><span class="token punctuation">{</span>            //一到递归的出口就输出数组，此数组为全排列            for<span class="token punctuation">(</span>int i<span class="token operator">=</span>0<span class="token punctuation">;</span>i<span class="token operator">&lt;=</span>end<span class="token punctuation">;</span>i++<span class="token punctuation">)</span><span class="token punctuation">{</span>            System.out.print<span class="token punctuation">(</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span>+<span class="token string">" "</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>            System.out.println<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>        else<span class="token punctuation">{</span>            for<span class="token punctuation">(</span>int j<span class="token operator">=</span>begin<span class="token punctuation">;</span>j<span class="token operator">&lt;=</span>end<span class="token punctuation">;</span>j++<span class="token punctuation">)</span><span class="token punctuation">{</span>                    swap<span class="token punctuation">(</span>begin,j<span class="token punctuation">)</span><span class="token punctuation">;</span>        //for循环将begin~end中的每个数放到begin位置中去                perm<span class="token punctuation">(</span>arr,begin+1,end<span class="token punctuation">)</span><span class="token punctuation">;</span>    //假设begin位置确定，那么对begin+1~end中的数继续递归     //递归                swap<span class="token punctuation">(</span>begin,j<span class="token punctuation">)</span><span class="token punctuation">;</span>        //换过去后再还原            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h1 id="分治：递归实现的快速排序"><a href="#分治：递归实现的快速排序" class="headerlink" title="分治：递归实现的快速排序"></a>分治：递归实现的快速排序</h1><pre class=" language-bash"><code class="language-bash">public class Quicksort <span class="token punctuation">{</span>    /**     * @param args     */    public static void main<span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        int<span class="token punctuation">[</span><span class="token punctuation">]</span> src <span class="token operator">=</span> <span class="token punctuation">{</span>7, 9, 2, 3, 6, 5, 4, 1, 8, 10<span class="token punctuation">}</span><span class="token punctuation">;</span>        System.out.print<span class="token punctuation">(</span><span class="token string">"原数组为："</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span>int i <span class="token keyword">:</span> src<span class="token punctuation">)</span> <span class="token punctuation">{</span>            System.out.print<span class="token punctuation">(</span><span class="token string">" "</span> + i<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        System.out.print<span class="token punctuation">(</span><span class="token string">"\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        quickSort<span class="token punctuation">(</span>src<span class="token punctuation">)</span><span class="token punctuation">;</span>        System.out.print<span class="token punctuation">(</span><span class="token string">"现数组为："</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span>int i <span class="token keyword">:</span> src<span class="token punctuation">)</span> <span class="token punctuation">{</span>            System.out.print<span class="token punctuation">(</span><span class="token string">" "</span> + i<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    /**     * 对整个源数组进行快速排序     * @param src     * @return     */    public static void quickSort<span class="token punctuation">(</span>int<span class="token punctuation">[</span><span class="token punctuation">]</span> src<span class="token punctuation">)</span> <span class="token punctuation">{</span>        sortPartision<span class="token punctuation">(</span>src, 0, src.length - 1<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    /**     * 排序分治区域       * @param src     * @param start     * @param end     */    private static void sortPartision<span class="token punctuation">(</span>int<span class="token punctuation">[</span><span class="token punctuation">]</span> src, int start, int end<span class="token punctuation">)</span> <span class="token punctuation">{</span>        int i <span class="token operator">=</span> start<span class="token punctuation">;</span>    //将开始赋值给i         int r <span class="token operator">=</span> end<span class="token punctuation">;</span>         //将结尾赋值给r        int x <span class="token operator">=</span> src<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>               <span class="token keyword">while</span> <span class="token punctuation">(</span>i <span class="token operator">&lt;</span> r<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">while</span> <span class="token punctuation">(</span>i <span class="token operator">&lt;</span> r <span class="token operator">&amp;&amp;</span> src<span class="token punctuation">[</span>r<span class="token punctuation">]</span> <span class="token operator">></span> x<span class="token punctuation">)</span> <span class="token punctuation">{</span>                r--<span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>src<span class="token punctuation">[</span>r<span class="token punctuation">]</span> <span class="token operator">&lt;</span> x<span class="token punctuation">)</span> <span class="token punctuation">{</span>                src<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> src<span class="token punctuation">[</span>r<span class="token punctuation">]</span><span class="token punctuation">;</span>                i++<span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">while</span> <span class="token punctuation">(</span>i <span class="token operator">&lt;</span> r <span class="token operator">&amp;&amp;</span> src<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;</span> x<span class="token punctuation">)</span> <span class="token punctuation">{</span>                i++<span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>src<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">></span> x<span class="token punctuation">)</span> <span class="token punctuation">{</span>                src<span class="token punctuation">[</span>r<span class="token punctuation">]</span> <span class="token operator">=</span> src<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>                r--<span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        src<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> x<span class="token punctuation">;</span>        int I <span class="token operator">=</span> i<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>I <span class="token operator">></span> start<span class="token punctuation">)</span> <span class="token punctuation">{</span>            sortPartision<span class="token punctuation">(</span>src, start, I-1<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>I <span class="token operator">&lt;</span> end<span class="token punctuation">)</span> <span class="token punctuation">{</span>            sortPartision<span class="token punctuation">(</span>src, I+1, end<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h1 id="分治：递归实现的合并排序"><a href="#分治：递归实现的合并排序" class="headerlink" title="分治：递归实现的合并排序"></a>分治：递归实现的合并排序</h1><pre class=" language-bash"><code class="language-bash">public class Mergesort <span class="token punctuation">{</span>    static int arr<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span>100, 20, 15, 30, 5, 75, 40, 12, 514<span class="token punctuation">}</span><span class="token punctuation">;</span>  //定义排序前的一个是数组    public static void main<span class="token punctuation">(</span>String args<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System.out.println<span class="token punctuation">(</span><span class="token string">"数据排序之前 ： "</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        // 排序前打印数组        printArray<span class="token punctuation">(</span>arr, 0, arr.length - 1<span class="token punctuation">)</span><span class="token punctuation">;</span>        System.out.println<span class="token punctuation">(</span><span class="token string">"-----------------------------"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        // 用递归实现排序        mergeSort<span class="token punctuation">(</span>0, arr.length - 1<span class="token punctuation">)</span><span class="token punctuation">;</span>        System.out.println<span class="token punctuation">(</span><span class="token string">"-----------------------------"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        // 排序后打印数组        System.out.println<span class="token punctuation">(</span><span class="token string">"排序后打印数组:"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        printArray<span class="token punctuation">(</span>arr, 0, arr.length - 1<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    /**     * 用于合并排序的递归算法     *     * @param start     * @param end     */    public static void mergeSort<span class="token punctuation">(</span>int start, int end<span class="token punctuation">)</span> <span class="token punctuation">{</span>        int mid <span class="token operator">=</span> <span class="token punctuation">(</span>start + end<span class="token punctuation">)</span> / 2<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>start <span class="token operator">&lt;</span> end<span class="token punctuation">)</span> <span class="token punctuation">{</span>            // 排序左半部分            mergeSort<span class="token punctuation">(</span>start, mid<span class="token punctuation">)</span><span class="token punctuation">;</span>            // 排序右半部分            mergeSort<span class="token punctuation">(</span>mid + 1, end<span class="token punctuation">)</span><span class="token punctuation">;</span>            // 合并左右两半            merge<span class="token punctuation">(</span>start, mid, end<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    /**     * @param start     * @param mid     * @param end     */    private static void merge<span class="token punctuation">(</span>int start, int mid, int end<span class="token punctuation">)</span> <span class="token punctuation">{</span>        // 初始化临时数组和索引        int<span class="token punctuation">[</span><span class="token punctuation">]</span> tempArray <span class="token operator">=</span> new int<span class="token punctuation">[</span>arr.length<span class="token punctuation">]</span><span class="token punctuation">;</span>        int tempArrayIndex <span class="token operator">=</span> start<span class="token punctuation">;</span>        System.out.print<span class="token punctuation">(</span><span class="token string">"合并前:  "</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        printArray<span class="token punctuation">(</span>arr, start, end<span class="token punctuation">)</span><span class="token punctuation">;</span>        int startIndex <span class="token operator">=</span> start<span class="token punctuation">;</span>        int midIndex <span class="token operator">=</span> mid + 1<span class="token punctuation">;</span>        // 它将迭代直到较小的列表到达结尾        <span class="token keyword">while</span> <span class="token punctuation">(</span>startIndex <span class="token operator">&lt;=</span> mid <span class="token operator">&amp;&amp;</span> midIndex <span class="token operator">&lt;=</span> end<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>arr<span class="token punctuation">[</span>startIndex<span class="token punctuation">]</span> <span class="token operator">&lt;</span> arr<span class="token punctuation">[</span>midIndex<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                tempArray<span class="token punctuation">[</span>tempArrayIndex++<span class="token punctuation">]</span> <span class="token operator">=</span> arr<span class="token punctuation">[</span>startIndex++<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                tempArray<span class="token punctuation">[</span>tempArrayIndex++<span class="token punctuation">]</span> <span class="token operator">=</span> arr<span class="token punctuation">[</span>midIndex++<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        // 复制剩余的元素        <span class="token keyword">while</span> <span class="token punctuation">(</span>startIndex <span class="token operator">&lt;=</span> mid<span class="token punctuation">)</span> <span class="token punctuation">{</span>            tempArray<span class="token punctuation">[</span>tempArrayIndex++<span class="token punctuation">]</span> <span class="token operator">=</span> arr<span class="token punctuation">[</span>startIndex++<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>midIndex <span class="token operator">&lt;=</span> end<span class="token punctuation">)</span> <span class="token punctuation">{</span>            tempArray<span class="token punctuation">[</span>tempArrayIndex++<span class="token punctuation">]</span> <span class="token operator">=</span> arr<span class="token punctuation">[</span>midIndex++<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        // 排序后将tempArray复制到实际数组        <span class="token keyword">for</span> <span class="token punctuation">(</span>int i <span class="token operator">=</span> start<span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> end<span class="token punctuation">;</span> i++<span class="token punctuation">)</span> <span class="token punctuation">{</span>            arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> tempArray<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        System.out.print<span class="token punctuation">(</span><span class="token string">"合并后:   "</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        printArray<span class="token punctuation">(</span>tempArray, start, end<span class="token punctuation">)</span><span class="token punctuation">;</span>        System.out.println<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    /**     * 打印数组     *     * @param arr   传入的数组     * @param start 遍历开始的位置     * @param end   遍历结束的位置     */    public static void printArray<span class="token punctuation">(</span>int arr<span class="token punctuation">[</span><span class="token punctuation">]</span>, int start, int end<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span>int i <span class="token operator">=</span> start<span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> end<span class="token punctuation">;</span> i++<span class="token punctuation">)</span>         <span class="token punctuation">{</span>            System.out.print<span class="token punctuation">(</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> + <span class="token string">" "</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        System.out.println<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法设计与分析 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Sandboxie破解</title>
      <link href="/2020/05/21/sandboxie-po-jie/"/>
      <url>/2020/05/21/sandboxie-po-jie/</url>
      
        <content type="html"><![CDATA[<blockquote><p>Sandboxie安装及破解<br>仅供学习使用,请支持正版！！！    </p></blockquote><h2 id="Sandboxie-安装及破解"><a href="#Sandboxie-安装及破解" class="headerlink" title="Sandboxie 安装及破解"></a><center><font size="+2"><code>Sandboxie 安装及破解</code></font></center></h2><h3 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h3><p>   1.点击进入<a href="https://www.sandboxie.com/DownloadSandboxie" target="_blank" rel="noopener">下载界面</a></p><p>   2.点击如下图位置进行下载</p><p>   <img src="https://res.cloudinary.com/valent/image/upload/v1566457584/Blog/Sandboxie/Sandboxie1_qgzwni.png" alt="">  </p><p>   3.进入我的<a href="https://pan.baidu.com/s/1HRKs9rSNBD_3fg-zEx6hmA" target="_blank" rel="noopener">百度云</a>进行下<code>载驱动文件</code>以及<code>注册机</code>（选择合适驱动文件）</p><p>   <img src="https://res.cloudinary.com/valent/image/upload/v1566458554/Blog/Sandboxie/Sandboxie2_mpoyuj.png" alt=""> </p><h3 id="安装、破解"><a href="#安装、破解" class="headerlink" title="安装、破解"></a>安装、破解</h3><p>   1.点击安装包进行安装  </p><p>   2.语言随你喜好（可任选） </p><p>   3.选择合适的<code>安装位置</code>并记住（等会要用到） </p><p>   4.安装完后不要点击下一步，这时候找到我们的<code>安装目录</code>，将我们之前下载驱动文件放入根目录,直接进行<code>覆盖</code></p><p>   <img src="https://res.cloudinary.com/valent/image/upload/v1566458772/Blog/Sandboxie/Sandboxie3_au8ogr.png" alt=""></p><p>   5.弄完上一步后把安装程序接着完成，然后以管理员运行我们之前下载的注册机 </p><p>   <img src="https://res.cloudinary.com/valent/image/upload/v1566459634/Blog/Sandboxie/Sandboxie4_hop6mc.png" alt=""> </p><p>   6.首先<code>指定</code>你的安装路径，然后<code>获取</code>你的安装版本，再<code>计算</code>机器码，输入你想要的<code>注册期限</code>,最后点击开始注册即可破解成功！！！  </p><p>   7.以下是我的配置（我现在的是最新版本，安装路径是我自定义的，最后注册期限为2099-08-22 相当于无限使用</p><p>   <img src="https://res.cloudinary.com/valent/image/upload/v1566460053/Blog/Sandboxie/Sandboxie6_rmmbnb.png" alt=""> </p><p>   <img src="https://res.cloudinary.com/valent/image/upload/v1566460102/Blog/Sandboxie/Sandboxie5_qrvtbo.png" alt=""> </p><p>   <img src="https://res.cloudinary.com/valent/image/upload/v1566460054/Blog/Sandboxie/Sandboxie7_xy1qqo.png" alt=""> </p><p>   8.最后进入软件，帮助-&gt;关于 显示注册信息</p><p>   <img src="https://res.cloudinary.com/valent/image/upload/v1566460355/Blog/Sandboxie/Sandboxie8_fma0nx.png" alt=""> </p><hr>]]></content>
      
      
      <categories>
          
          <category> 教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 破解 </tag>
            
            <tag> Sandboxie </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux学习（一）</title>
      <link href="/2020/05/20/linux-xue-xi-yi/"/>
      <url>/2020/05/20/linux-xue-xi-yi/</url>
      
        <content type="html"><![CDATA[<blockquote><p>Linux学习过程<br>坚持更新  </p></blockquote><h1 id="Linux系统安装（vm虚拟机安装）"><a href="#Linux系统安装（vm虚拟机安装）" class="headerlink" title="Linux系统安装（vm虚拟机安装）"></a>Linux系统安装（vm虚拟机安装）</h1><h2 id="IOS镜像下载"><a href="#IOS镜像下载" class="headerlink" title="IOS镜像下载"></a>IOS镜像下载</h2><p>   1.<a href="https://www.linux.org/pages/download/" target="_blank" rel="noopener">官方网站</a>镜像下载（需要翻墙）<br>   2.<a href="https://linux.cn/share/distro/" target="_blank" rel="noopener">Linux中国</a>镜像下载（无需翻墙）<br>   3.或者自己找到镜像网站，进行下载  </p><h2 id="VM虚拟机下载"><a href="#VM虚拟机下载" class="headerlink" title="VM虚拟机下载"></a>VM虚拟机下载</h2><p>   1.<a href="https://my.vmware.com/cn/web/vmware/info/slug/desktop_end_user_computing/vmware_workstation_pro/15_0" target="_blank" rel="noopener">vm15-官网</a>下载<br>   2.下载后自行安装  </p><h2 id="ISO镜像VM安装（此处以kaili-Linux为例）"><a href="#ISO镜像VM安装（此处以kaili-Linux为例）" class="headerlink" title="ISO镜像VM安装（此处以kaili Linux为例）"></a>ISO镜像VM安装（此处以kaili Linux为例）</h2><p>   1.创建新的虚拟机（个人一般选择自定义）<br>     <img src="https://res.cloudinary.com/valent/image/upload/v1567515573/Blog/Linux/Linux%28%E4%B8%80%29/Linux1_sdts62.png" alt=""><br>   2.点击下一步<br>     <img src="https://res.cloudinary.com/valent/image/upload/v1567516398/Blog/Linux/Linux%28%E4%B8%80%29/Linux2_bkzuhm.png" alt=""><br>   3.没有检测到Linux（选择稍后安装）<br>     <img src="https://res.cloudinary.com/valent/image/upload/v1567517856/Blog/Linux/Linux%28%E4%B8%80%29/Linux3_qutwnd.png" alt=""><br>   4.Kaili-Linux选择Deblan (选择你镜像的版本)<br>     <img src="https://res.cloudinary.com/valent/image/upload/v1567517856/Blog/Linux/Linux%28%E4%B8%80%29/Linux4_zwrgl3.png" alt=""><br>   5.选择存储位置和名称<br>     <img src="https://res.cloudinary.com/valent/image/upload/v1567517856/Blog/Linux/Linux%28%E4%B8%80%29/Linux5_xvcqof.png" alt=""><br>   6.选择适合你的配置<br>     <img src="https://res.cloudinary.com/valent/image/upload/v1567517856/Blog/Linux/Linux%28%E4%B8%80%29/Linux6_d8pzbn.png" alt=""><br>   7.根据自己电脑配置，自行选择<br>     <img src="https://res.cloudinary.com/valent/image/upload/v1567517856/Blog/Linux/Linux%28%E4%B8%80%29/Linux7_ft0k9y.png" alt=""><br>   8.自行选择（个人选择 桥接模式）<br>     <img src="https://res.cloudinary.com/valent/image/upload/v1567517856/Blog/Linux/Linux%28%E4%B8%80%29/Linux8_hbf0rs.png" alt=""><br>   9.默认配置即可<br>     <img src="https://res.cloudinary.com/valent/image/upload/v1567517856/Blog/Linux/Linux%28%E4%B8%80%29/Linux9_lbqpzv.png" alt=""><br>   10.默认配置即可<br>     <img src="https://res.cloudinary.com/valent/image/upload/v1567517857/Blog/Linux/Linux%28%E4%B8%80%29/Linux10_c7fyoa.png" alt=""><br>   11.创建新的虚拟磁盘即可<br>     <img src="https://res.cloudinary.com/valent/image/upload/v1567517857/Blog/Linux/Linux%28%E4%B8%80%29/Linux11_lf6clq.png" alt=""><br>   12.按需求设置<br>     <img src="https://res.cloudinary.com/valent/image/upload/v1567517857/Blog/Linux/Linux%28%E4%B8%80%29/Linux12_ceuwcw.png" alt=""><br>   13.配置完成，接下来开始安装  </p><h2 id="开始虚拟系统安装配置"><a href="#开始虚拟系统安装配置" class="headerlink" title="开始虚拟系统安装配置"></a>开始虚拟系统安装配置</h2><p>   1.选择Graphical install(图形安装)<br>     <img src="https://res.cloudinary.com/valent/image/upload/v1567524302/Blog/Linux/Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%B8%80%EF%BC%892/Linux-1_sc1ki4.png" alt=""><br>   2.选择系统语言<br>     <img src="https://res.cloudinary.com/valent/image/upload/v1567524301/Blog/Linux/Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%B8%80%EF%BC%892/Linux-2_htofwj.png" alt=""><br>   3.选择国家地区<br>     <img src="https://res.cloudinary.com/valent/image/upload/v1567524303/Blog/Linux/Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%B8%80%EF%BC%892/Linux-3_qvdbzo.png" alt=""><br>   4.配置键盘<br>     <img src="https://res.cloudinary.com/valent/image/upload/v1567524302/Blog/Linux/Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%B8%80%EF%BC%892/Linux-4_zie6qs.png" alt=""><br>   5.输入自己想要的主机名，也可以点击继续跳过<br>     <img src="https://res.cloudinary.com/valent/image/upload/v1567524302/Blog/Linux/Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%B8%80%EF%BC%892/Linux-5_eyhe4m.png" alt=""><br>   6.配置域名（可跳过）<br>     <img src="https://res.cloudinary.com/valent/image/upload/v1567524302/Blog/Linux/Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%B8%80%EF%BC%892/Linux-6_xxjtnd.png" alt=""><br>   7.设置用户密码<br>     <img src="https://res.cloudinary.com/valent/image/upload/v1567524303/Blog/Linux/Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%B8%80%EF%BC%892/Linux-7_hbwxr0.png" alt=""><br>   8.磁盘分区（新手推荐选择第一个）<br>     <img src="https://res.cloudinary.com/valent/image/upload/v1567524303/Blog/Linux/Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%B8%80%EF%BC%892/Linux-8_ybtypj.png" alt=""><br>   9.按步骤走<br>     <img src="https://res.cloudinary.com/valent/image/upload/v1567524304/Blog/Linux/Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%B8%80%EF%BC%892/Linux-9_weeh6k.png" alt=""><br>   10.按步骤走（可以根据自己的喜好配置）<br>     <img src="https://res.cloudinary.com/valent/image/upload/v1567524303/Blog/Linux/Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%B8%80%EF%BC%892/Linux-10_bnpav6.png" alt=""><br>   11.结束分区<br>     <img src="https://res.cloudinary.com/valent/image/upload/v1567524340/Blog/Linux/Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%B8%80%EF%BC%892/Linux-11_e2jbrn.png" alt=""><br>   12.确定修改<br>     <img src="https://res.cloudinary.com/valent/image/upload/v1567524339/Blog/Linux/Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%B8%80%EF%BC%892/Linux-12_pcftpa.png" alt=""><br>   13.<br>     <img src="https://res.cloudinary.com/valent/image/upload/v1567524303/Blog/Linux/Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%B8%80%EF%BC%892/Linux-13_xsmumy.png" alt=""><br>   14.将GRUB安装至硬盘<br>     <img src="https://res.cloudinary.com/valent/image/upload/v1567524307/Blog/Linux/Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%B8%80%EF%BC%892/Linux-14_yu1efo.png" alt=""><br>   15.默认设备<br>     <img src="https://res.cloudinary.com/valent/image/upload/v1567524305/Blog/Linux/Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%B8%80%EF%BC%892/Linux-15._js0ce4.png" alt=""><br>   16.安装完成<br>     <img src="https://res.cloudinary.com/valent/image/upload/v1567524306/Blog/Linux/Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%B8%80%EF%BC%892/Linux-16_p3idkv.png" alt=""><br>   17.用户名初始为root<br>     <img src="https://res.cloudinary.com/valent/image/upload/v1567524305/Blog/Linux/Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%B8%80%EF%BC%892/Linux-17_vcpz2b.png" alt=""><br>   18.填入自己之前填的密码<br>     <img src="https://res.cloudinary.com/valent/image/upload/v1567524306/Blog/Linux/Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%B8%80%EF%BC%892/Linux-18_er7alo.png" alt=""><br>   19.出现以下界面，则表明系统安装完成<br>     <img src="https://res.cloudinary.com/valent/image/upload/v1567524338/Blog/Linux/Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%B8%80%EF%BC%892/Linux-19_pujrrp.png" alt=""></p><hr>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JET-BRAINS 软件破解</title>
      <link href="/2020/05/19/intellij-ruan-jian-po-jie/"/>
      <url>/2020/05/19/intellij-ruan-jian-po-jie/</url>
      
        <content type="html"><![CDATA[<blockquote><p>JET-BRAINS 软件破解教程<br>仅供学习使用，请支持正版！！！  </p></blockquote><h1 id="JET-BRAINS软件永久破解（这里以IDEA为例子）"><a href="#JET-BRAINS软件永久破解（这里以IDEA为例子）" class="headerlink" title="JET-BRAINS软件永久破解（这里以IDEA为例子）"></a>JET-BRAINS软件永久破解（这里以<code>IDEA</code>为例子）</h1><h2 id="下载安装-2019-2-X版本"><a href="#下载安装-2019-2-X版本" class="headerlink" title="下载安装(2019 2.X版本)"></a>下载安装(2019 2.X版本)</h2><p>  1.进入<a href="https://www.jetbrains.com/idea/" target="_blank" rel="noopener">官网</a>进行下载IDEA最新版本 </p><p>  2.下载完成后按步骤安装即可  </p><h2 id="破解"><a href="#破解" class="headerlink" title="破解"></a>破解</h2><p>   1.进入我的<a href="https://pan.baidu.com/s/1UHxUZzOpaUqk5rx5xwpQ9w" target="_blank" rel="noopener">百度云</a>，下载<code>破解补丁</code></p><p>   2.将破解补丁放在一个没有中文的目录中 如：D:--Code–\JET-BRAINS\JET\jetbrains-agent.jar  (这是我的存放目录)</p><p>   3.进入IDEA的bin目录 分别打开<code>idea.exe.vmoptions</code>、<code>idea64.exe.vmoptions</code>在最后面添加-javaagent:D:--Code–\JET-BRAINS\JET\jetbrains-agent.jar（后面的路径为你保存破解补丁的位置）   </p><p>   <img src="https://res.cloudinary.com/valent/image/upload/v1566545071/Blog/JET-BRAINS/IDEA/IDEA_vhbtgw.png" alt=""></p><p>   4.添加完成后进入软件，选择使用<code>Evaluate for free</code></p><p>   5.选择 <code>Configure - Edit Custom VM Options</code>，在弹出的窗口确定末尾是刚刚修改的 -javaagent:-javaagent:D:--Code–\JET-BRAINS\JET\jetbrains-agent.jar （如果提示创建，选择是，在末尾再添加上面的参数）</p><p>   <img src="https://res.cloudinary.com/valent/image/upload/v1566545701/Blog/JET-BRAINS/IDEA/IDEA1_rabkjs.png" alt="">  </p><p>   以下结果显示的，就是我刚刚添加的</p><p>   <img src="https://res.cloudinary.com/valent/image/upload/v1566545701/Blog/JET-BRAINS/IDEA/IDEA2_esnfvo.png" alt=""></p><p>   6.选择 <code>Manage License</code>， License Server 填写  <a href="http://jetbrains-license-server" target="_blank" rel="noopener">http://jetbrains-license-server</a>  点击Activate</p><p>   <img src="https://res.cloudinary.com/valent/image/upload/v1566546375/Blog/JET-BRAINS/IDEA/IDEA3_yejepj.png" alt=""></p><p>   7.重启你的 IDEA ,看下是否已经<span id="post-red">破解成功</span></p><p>   <img src="https://res.cloudinary.com/valent/image/upload/v1566546535/Blog/JET-BRAINS/IDEA/IDEA4_e9tdo9.png" alt=""></p><p>   8.没有显示授权日期，也能正常使用，稳定奔现！！！</p><h2 id="注意："><a href="#注意：" class="headerlink" title="注意："></a>注意：</h2><p>   1.如果第 6 步提示激活不了的朋友们，打开 Windows 的 hosts 文件，路径一般在 C:\Windows\System32\drivers\etc 下，在末尾加上</p><pre class=" language-bash"><code class="language-bash">0.0.0.0 account.jetbrains.com</code></pre><p>   然后保存再点击激活</p><p>   2.其它<code>JET-BRAINS软件</code>破解也是与IDEA破解步骤一样  </p><h1 id="JetBrains-系列软件汉化包"><a href="#JetBrains-系列软件汉化包" class="headerlink" title="JetBrains 系列软件汉化包"></a>JetBrains 系列软件汉化包</h1><p>   1.进入我的<a href="https://pan.baidu.com/s/1-AmIq6npwTY44wuTJ1v7lg" target="_blank" rel="noopener">百度云</a>下载JetBrains 系列软件汉化包  </p><p>   2.进入JetBrains 软件安装目录的<code>lib</code>目录 </p><p>   3.放入适合你版本的安装包，重启软件，即可汉化完成！！！</p>]]></content>
      
      
      <categories>
          
          <category> 教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JET-BRAINS </tag>
            
            <tag> 破解 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
